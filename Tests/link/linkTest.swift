// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*
 #
 # SPDX-License-Identifier: BSD-2-Clause
 #
 # Copyright 2017 Shivansh Rai
 # All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions
 # are met:
 # 1. Redistributions of source code must retain the above copyright
 #    notice, this list of conditions and the following disclaimer.
 # 2. Redistributions in binary form must reproduce the above copyright
 #    notice, this list of conditions and the following disclaimer in the
 #    documentation and/or other materials provided with the distribution.
 #
 # THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 # ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 # ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 # OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 # HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 # LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 # OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 # SUCH DAMAGE.
 #
 */

import ShellTesting
import CMigration

struct linkTest : ShellTest {
  var cmd = "link"
  var suiteBundle = "linkTest"

  @Test("Verify that link(1) requires exactly two arguments") func link_argc() async throws {
    try await run(status: 1, error: /usage: link/, args: ["foo"])
    try await run(status: 1, error: /No such file/, args: ["foo", "bar"])
    try await run(status: 1, error: /No such file/, args: ["--", "foo", "bar"])
    try await run(status: 1, error: /usage: link/, args: ["foo", "bar", "baz"])
  }

  @Test("Verify that link(1) creates a link") func link_basic() async throws {
    let foo = try tmpfile("A14", "")
    let bar = try tmpfile("B14")

    try await run(args: [foo, bar])

    let aa = try FileMetadata(for: foo.path, followSymlinks: false)
    let bb = try FileMetadata(for: bar.path, followSymlinks: false)
    #expect(aa.inode == bb.inode)
    rm(bar)

    try FileManager.default.createSymbolicLink(at: bar, withDestinationURL: foo)

    let baz = try tmpfile("C14")
    try await run(args: [bar, baz])

    let cc = try FileMetadata(for: foo.path, followSymlinks: false)
    let dd = try FileMetadata(for: baz.path, followSymlinks: false)
    #expect(cc.inode == dd.inode)
  }

  @Test("Verify that link(1) fails if the target exists") func link_eexist() async throws {
    let foo = try tmpfile("A15", "")
    let bar = try tmpfile("B15", "")

    let baz = try tmpfile("C15")
    let ne = try tmpfile("non-existent")

    try await run(status: 1, error: /link: B15: File exists/, args: [foo, bar])
    try FileManager.default.createSymbolicLink(at: baz, withDestinationURL: ne)

    try await run(status: 1, error: /link: C15: File exists/, args: [foo, baz])
    rm(foo, bar)
  }

  @Test("Verify that link(1) fails if the source is a directory") func link_eisdir() async throws {
    let foo = try tmpdir("A16")
    let bar = try tmpfile("B16")
    let baz = try tmpfile("C16")
    try await run(status: 1, error: /link: A16: Is a directory/, args: [foo, bar] )
    try FileManager.default.createSymbolicLink(at: bar, withDestinationURL: foo)
    try await run(status: 1, error: /link: B16: Is a directory/, args: [bar, baz] )
    rm(foo, bar, baz)
  }
}
