// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego and Lance
 * Visser of Convex Computer Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration

/*
 * def --
 * Copy input to output.  Input is buffered until reaches obs, and then
 * output until less than obs remains.  Only a single buffer is used.
 * Worst case buffer calculation is (ibs + obs - 1).
 */
func def(_ ddc : inout DDContext) {
//	u_char *inp;
//	const u_char *t;
//	size_t cnt;

  if let t = ddc.ctab {
    var cnt = ddc.inx.dbrcnt
    var inp = ddc.inx.dbp - cnt

    for (; cnt--; ++inp) {
      *inp = t[*inp];
    }
  }

	/* Make the output buffer look right. */
  ddc.out.dbp = ddc.inx.dbp
  ddc.out.dbcnt = ddc.inx.dbcnt

  if ddc.inx.dbcnt >= ddc.out.dbsz {
		/* If the output buffer is full, write it. */
		dd_out(0);

		/*
		 * dd_out copies the leftover output to the beginning of
		 * the buffer and resets the output buffer.  Reset the
		 * input buffer to match it.
	 	 */
    ddc.inx.dbp = ddc.out.dbp;
    ddc.inx.dbcnt = ddc.out.dbcnt;
	}
}

func def_close(_ ddc : inout DDContext) {
	// Just update the count, everything is already in the buffer.
  if 0 != ddc.inx.dbcnt {
    ddc.out.dbcnt = ddc.inx.dbcnt
  }
}

/*
 * Copy variable length newline terminated records with a max size cbsz
 * bytes to output.  Records less than cbs are padded with spaces.
 *
 * max in buffer:  MAX(ibs, cbsz)
 * max out buffer: obs + cbsz
 */
func block(_ ddc : inout DDContext) {
//	u_char *inp, *outp;
//	const u_char *t;
//	size_t cnt, maxlen;
  static int intrunc;
//	int ch;

	/*
	 * Record truncation can cross block boundaries.  If currently in a
	 * truncation state, keep tossing characters until reach a newline.
	 * Start at the beginning of the buffer, as the input buffer is always
	 * left empty.
	 */
	if (intrunc) {
    var cnt = ddc.inx.dbrcnt
    var inp  ddc.inx.db
    for (; cnt && *inp++ != '\n'; --cnt) {
      ;
    }
		if cnt == 0 {
      ddc.inx.dbcnt = 0;
      ddc.inx.dbp = ddc.inx.db
			return
		}
		intrunc = 0;
		/* Adjust the input buffer numbers. */
    ddc.inx.dbcnt = cnt - 1
    ddc.inx.dbp = inp + cnt - 1
	}

	/*
	 * Copy records (max cbsz size chunks) into the output buffer.  The
	 * translation is done as we copy into the output buffer.
	 */
	ch = 0;
	for (inp = in.dbp - in.dbcnt, outp = out.dbp; in.dbcnt;) {
		maxlen = MIN(cbsz, (size_t)in.dbcnt);
    if ((t = ctab) != NULL) {
      for (cnt = 0; cnt < maxlen && (ch = *inp++) != '\n';
           ++cnt) {
        *outp++ = t[ch];
      }
    }
    else {
      for (cnt = 0; cnt < maxlen && (ch = *inp++) != '\n';
           ++cnt) {
        *outp++ = ch;
      }
    }
		/*
		 * Check for short record without a newline.  Reassemble the
		 * input block.
		 */
		if (ch != '\n' && (size_t)in.dbcnt < cbsz) {
			(void)memmove(in.db, in.dbp - in.dbcnt, in.dbcnt);
			break;
		}

		/* Adjust the input buffer numbers. */
		in.dbcnt -= cnt;
    if (ch == '\n') {
      --in.dbcnt;
    }

		/* Pad short records with spaces. */
    if (cnt < cbsz) {
      (void)memset(outp, ctab ? ctab[' '] : ' ', cbsz - cnt);
    }
		else {
			/*
			 * If the next character wouldn't have ended the
			 * block, it's a truncation.
			 */
      if (!in.dbcnt || *inp != '\n') {
        ++st.trunc;
      }

			/* Toss characters to a newline. */
      for (; in.dbcnt && *inp++ != '\n'; --in.dbcnt) {
        ;
      }
      if (!in.dbcnt) {
        intrunc = 1;
      }
      else {
        --in.dbcnt;
      }
		}

		/* Adjust output buffer numbers. */
    ddc.out.dbp += ddc.cbsz
    ddc.out.dbcnt += ddc.cbsz
    if (ddc.out.dbcnt >= ddc.out.dbsz) {
      dd_out(0)
    }
    outp = ddc.out.dbp
	}
  ddc.inx.dbp = ddc.inx.db + ddc.inx.dbcnt
}

func block_close(_ ddc : inout DDContext) {
	/*
	 * Copy any remaining data into the output buffer and pad to a record.
	 * Don't worry about truncation or translation, the input buffer is
	 * always empty when truncating, and no characters have been added for
	 * translation.  The bottom line is that anything left in the input
	 * buffer is a truncated record.  Anything left in the output buffer
	 * just wasn't big enough.
	 */
  if 0 != ddc.inx.dbcnt {
		++st.trunc;
		(void)memmove(out.dbp, in.dbp - in.dbcnt, in.dbcnt);
		(void)memset(out.dbp + in.dbcnt, ctab ? ctab[' '] : ' ',
		    cbsz - in.dbcnt);
    ddc.out.dbcnt += ddc.cbsz
	}
}

/*
 * Convert fixed length (cbsz) records to variable length.  Deletes any
 * trailing blanks and appends a newline.
 *
 * max in buffer:  MAX(ibs, cbsz) + cbsz
 * max out buffer: obs + cbsz
 */
func unblock(_ ddc : inout DDContext) {
//	u_char *inp;
//	const u_char *t;
//	size_t cnt;

	/* Translation and case conversion. */
  if let t = ddc.ctab {
    var cnt = ddc.inx.dbrcnt
    var inp = ddc.inx.dbp - cnt
    for (; cnt--; ++inp) {
      *inp = t[*inp];
    }
  }
	/*
	 * Copy records (max cbsz size chunks) into the output buffer.  The
	 * translation has to already be done or we might not recognize the
	 * spaces.
	 */
  for (inp = ddc.inx.db; ddc.inx.dbcnt >= cbsz; inp += cbsz, ddc.inx.dbcnt -= ddc.cbsz) {
    for (t = inp + cbsz - 1; t >= inp && *t == ' '; --t) {
      ;
    }
		if (t >= inp) {
			var cnt = t - inp + 1;
			memmove(out.dbp, inp, cnt);
			out.dbp += cnt;
			out.dbcnt += cnt;
		}
		*out.dbp++ = '\n';
    if (++out.dbcnt >= ddc.out.dbsz) {
      dd_out(0);
    }
	}
  if 0 != ddc.inx.dbcnt {
    memmove(ddc.inx.db, ddc.inx.dbp - ddc.inx.dbcnt, ddc.inx.dbcnt)
  }
  ddc.inx.dbp = ddc.inx.db + ddc.inx.dbcnt
}

func unblock_close(_ ddc : inout DDContext) {
//	u_char *t;
//	size_t cnt;

  if 0 != ddc.inx.dbcnt {
    warnx("\(ddc.inx.name): short input record")
    var t = ddc.inx.db + ddc.inx.dbcnt - 1
    for (; t >= ddc.inx.db && *t == ' '; --t) {
      ;
    }
    if (t >= ddc.inx.db) {
      let cnt = t - ddc.inx.db + 1;
      memmove(ddc.out.dbp, ddc.inx.db, cnt)
      ddc.out.dbp += cnt;
      ddc.out.dbcnt += cnt;
		}
    ddc.out.dbcnt += 1
    ddc.out.dbp++ = '\n';
	}
}
