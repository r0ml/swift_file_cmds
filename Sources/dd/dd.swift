// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego and Lance
 * Visser of Convex Computer Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Darwin

@main struct dd : ShellCommand {

/*
IO	in, out;		/* input/output state */
STAT	st;			/* statistics */
void	(*cfunc)(void);		/* conversion function */
uintmax_t cpy_cnt;		/* # of blocks to copy */
static off_t	pending = 0;	/* pending seek if sparse */
uint64_t	ddflags = 0;	/* conversion options */
size_t	cbsz;			/* conversion block size */
uintmax_t files_cnt = 1;	/* # of files to copy */
const	u_char *ctab;		/* conversion table */
char	fill_char;		/* Character to fill with if defined */
size_t	speed = 0;		/* maximum speed, in bytes per second */
volatile sig_atomic_t need_summary;
volatile sig_atomic_t need_progress;
volatile sig_atomic_t kill_signal;
*/


int
main(int argc __unused, char *argv[])
{
	struct itimerval itv = { { 1, 0 }, { 1, 0 } }; /* SIGALARM every second, if needed */

	(void)siginterrupt(SIGINT, 1);
	(void)signal(SIGINT, terminate);

//	(void)setlocale(LC_CTYPE, "");
  var ddc = DDContext()
	jcl(argv, &ddc)
	setup(&ddc)

	(void)signal(SIGINFO, siginfo_handler);
  if ddc.ddflags.contains(.C_PROGRESS) {
		(void)signal(SIGALRM, sigalarm_handler);
		setitimer(ITIMER_REAL, &itv, NULL);
	}

	atexit(summary);

  while (files_cnt--) {
    dd_in(ddc)
  }

	dd_close();
	/*
	 * Some devices such as cfi(4) may perform significant amounts
	 * of work when a write descriptor is closed.  Close the out
	 * descriptor explicitly so that the summary handler (called
	 * from an atexit() hook) includes this work.
	 */
  if (close(out.fd) == -1 && errno != EINTR) {
    err(1, "close");
  }
	exit(0);
}

func parity( _ c : UInt8) -> Bool {
	let i = c ^ (c >> 1) ^ (c >> 2) ^ (c >> 3) ^
	    (c >> 4) ^ (c >> 5) ^ (c >> 6) ^ (c >> 7);
	return (i & 1) == 1
}

  func setup(_ ddc : inout DDContext) {
//	u_int cnt;
//	int iflags, oflags;

    if ddc.inx.name == nil {
      ddc.inx.name = "stdin";
      ddc.inx.fd = FileDescriptor.standardInput
	} else {
		iflags = 0;

		check_terminate();
    ddc.inx.fd = open(ddc.inx.name, O_RDONLY | iflags, 0);
		check_terminate();
    if (ddc.inx.fd == -1) {
      err(1, ddc.inx.name);
    }

    if ddc.ddflags.contains(.C_IDIRECT) {
      Darwin.fcntl(ddc.inx.fd, F_NOCACHE, 1);
    }

	}

    getfdtype(&ddc.inx);

    if (files_cnt > 1 && !ddc.inx.flags.contains(.ISTAPE)) {
    errx(1, "files is not supported for non-tape devices")
  }

    if (ddc.out.name == nil) {
		/* No way to check for read access here. */
      ddc.out.fd = FileDescriptor.standardOutput
      ddc.out.name = "stdout";
      if ddc.ddflags.contains(.C_OFSYNC) {
        oflags = fcntl(ddc.out.fd, F_GETFL);
      if (oflags == -1) {
        err(1, "unable to get fd flags for stdout");
      }
			oflags |= O_FSYNC;
        if (fcntl(ddc.out.fd, F_SETFL, oflags) == -1) {
        err(1, "unable to set fd flags for stdout");
      }
		}
	} else {
		oflags = O_CREAT;
    if (!(ddflags & (C_SEEK | C_NOTRUNC))) {
      oflags |= O_TRUNC;
    }
    if ddc.ddflags.contains(.C_OFSYNC) {
      oflags |= O_FSYNC;
    }

		check_terminate();
    ddc.out.fd = open(ddc.out.name, O_RDWR | oflags, DEFFILEMODE);
		check_terminate();
		/*
		 * May not have read access, so try again with write only.
		 * Without read we may have a problem if output also does
		 * not support seeks.
		 */
		if (out.fd == -1) {
      ddc.out.fd = open(out.name, O_WRONLY | oflags, DEFFILEMODE);
			check_terminate();
      ddc.out.flags.insert(.NOREAD)
		}

    if (ddflags & C_ODIRECT) {
      (void)fcntl(out.fd, F_NOCACHE, 1);
    }

    if (out.fd == -1) {
      err(1, "%s", out.name);
    }
	}

    getfdtype(&ddc.out);

/*#ifndef __APPLE__
  if (caph_rights_limit(out.fd, &rights) == -1) {
    err(1, "unable to limit capability rights");
  }
  if (caph_ioctls_limit(out.fd, cmds, nitems(cmds)) == -1) {
    err(1, "unable to limit capability rights");
  }

	if (in.fd != STDIN_FILENO && out.fd != STDIN_FILENO) {
    if (caph_limit_stdin() == -1) {
      err(1, "unable to limit capability rights");
    }
	}

	if (in.fd != STDOUT_FILENO && out.fd != STDOUT_FILENO) {
    if (caph_limit_stdout() == -1) {
      err(1, "unable to limit capability rights");
    }
	}

	if (in.fd != STDERR_FILENO && out.fd != STDERR_FILENO) {
    if (caph_limit_stderr() == -1) {
      err(1, "unable to limit capability rights");
    }
	}
#endif
 */

	/*
	 * Allocate space for the input and output buffers.  If not doing
	 * record oriented I/O, only need a single buffer.
	 */
	if (!(ddflags & (C_BLOCK | C_UNBLOCK))) {
    if ((in.db = malloc((size_t)out.dbsz + in.dbsz - 1)) == NULL) {
      err(1, "input buffer");
    }
		out.db = in.db;
	} else if ((in.db = malloc(MAX((size_t)in.dbsz, cbsz) + cbsz)) == NULL ||
             (out.db = malloc(out.dbsz + cbsz)) == NULL) {
    err(1, "output buffer");
  }

	/* dbp is the first free position in each buffer. */
	in.dbp = in.db;
	out.dbp = out.db;

	/* Position the input/output streams. */
  if (in.offset) {
    pos_in();
  }
  if (out.offset) {
    pos_out();
  }

	/*
	 * Truncate the output file.  If it fails on a type of output file
	 * that it should _not_ fail on, error out.
	 */
	if ((ddflags & (C_OF | C_SEEK | C_NOTRUNC)) == (C_OF | C_SEEK) &&
      out.flags & ISTRUNC) {
    if (ftruncate(out.fd, out.offset * out.dbsz) == -1) {
      err(1, "truncating %s", out.name);
    }
  }

	if (ddflags & (C_LCASE  | C_UCASE | C_ASCII | C_EBCDIC | C_PARITY)) {
		if (ctab != NULL) {
      for (cnt = 0; cnt <= 0377; ++cnt) {
        casetab[cnt] = ctab[cnt];
      }
		} else {
      for (cnt = 0; cnt <= 0377; ++cnt) {
        casetab[cnt] = cnt;
      }
		}
    if ddc.ddflags.contains(.C_PARITY) && !ddc.ddflags.contains(.C_ASCII) {
			/*
			 * If the input is not EBCDIC, and we do parity
			 * processing, strip input parity.
			 */
      for (cnt = 200; cnt <= 0377; ++cnt) {
        casetab[cnt] = casetab[cnt & 0x7f];
      }
		}
    if ddc.ddflags.contains(.C_LCASE) {
      for (cnt = 0; cnt <= 0377; ++cnt) {
        casetab[cnt] = tolower(casetab[cnt]);
      }
    } else if ddc.ddflags.contains(.C_UCASE) {
      for (cnt = 0; cnt <= 0377; ++cnt) {
        casetab[cnt] = toupper(casetab[cnt]);
      }
		}
    if ddc.ddflags.contains(.C_PARITY) {
			/*
			 * This should strictly speaking be a no-op, but I
			 * wonder what funny LANG settings could get us.
			 */
      for (cnt = 0; cnt <= 0377; ++cnt) {
        casetab[cnt] = casetab[cnt] & 0x7f;
      }
		}
    if ddc.ddflags.contains(.C_PARSET) {
      for (cnt = 0; cnt <= 0377; ++cnt) {
        casetab[cnt] = casetab[cnt] | 0x80;
      }
		}
    if ddc.ddflags.contains(.C_PAREVEN) {
      for (cnt = 0; cnt <= 0377; ++cnt) {
        if (parity(casetab[cnt])) {
          casetab[cnt] = casetab[cnt] | 0x80;
        }
      }
		}
    if ddc.ddflags.contains(.C_PARODD) {
      for (cnt = 0; cnt <= 0377; ++cnt) {
        if (!parity(casetab[cnt])) {
          casetab[cnt] = casetab[cnt] | 0x80;
        }
      }
		}

		ctab = casetab;
	}

  if (clock_gettime(CLOCK_MONOTONIC, &st.start)) {
    err(1, "clock_gettime");
  }
}

  func getfdtype(_ io : inout IO) {
	struct stat sb;
	int type;

  if (fstat(io->fd, &sb) == -1) {
    err(1, "%s", io->name);
  }
  if (S_ISREG(sb.st_mode)) {
    io->flags |= ISTRUNC;
  }
	if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode)) {
		if (ioctl(io->fd, FIODTYPE, &type) == -1) {
			err(1, "%s", io->name);
		} else {
		/* MacOSX uses enumeration for type not a bitmask */
      if (type == D_TAPE) {
        io->flags |= ISTAPE;
      }
			else if (type == D_DISK || type == D_TTY) {

				io->flags |= ISSEEK;
			}

        if (S_ISCHR(sb.st_mode) && (type != D_TAPE)) {
          io->flags |= ISCHR;
        }
		}
		return;
	}
	errno = 0;
    if (lseek(io->fd, (off_t)0, SEEK_CUR) == -1 && errno == ESPIPE) {
      io->flags |= ISPIPE;
    }
    else {
      io->flags |= ISSEEK;
    }
}

/*
 * Limit the speed by adding a delay before every block read.
 * The delay (t_usleep) is equal to the time computed from block
 * size and the specified speed limit (t_target) minus the time
 * spent on actual read and write operations (t_io).
 */
func speed_limit() {
	static double t_prev, t_usleep;
	double t_now, t_io, t_target;

	t_now = secs_elapsed();
	t_io = t_now - t_prev - t_usleep;
	t_target = (double)in.dbsz / (double)speed;
	t_usleep = t_target - t_io;
  if (t_usleep > 0) {
    usleep(t_usleep * 1000000);
  }
  else {
    t_usleep = 0;
  }
	t_prev = t_now;
}

func swapbytes(void *v, size_t len) {
	unsigned char *p = v;
	unsigned char t;

	while (len > 1) {
		t = p[0];
		p[0] = p[1];
		p[1] = t;
		p += 2;
		len -= 2;
	}
}

  func dd_in(_ ddc : inout DDContext) {
	ssize_t n;

  while true {
		switch (cpy_cnt) {
		case -1:			/* count=0 was specified */
			return;
		case 0:
			break;
		default:
        if (ddc.st.in_full + ddc.st.in_part >= cpy_cnt) {
          return;
        }
			break;
		}

    if ddc.speed > 0 {
      speed_limit()
    }

		/*
		 * Zero the buffer first if sync; if doing block operations,
		 * use spaces.
		 */
    if ddc.ddflags.contains(.C_SYNC) {
      if ddc.ddflags.contains(.C_FILL) {
        memset(ddc.inx.dbp, fill_char, ddc.inx.dbsz);
      }
      else if ddc.ddflags.contains([.C_BLOCK, .C_UNBLOCK]) {
        memset(ddc.inx.dbp, " ", ddc.inx.dbsz);
      }
      else {
        memset(ddc.inx.dbp, 0, ddc.inx.dbsz);
      }
		}

		in.dbrcnt = 0;
fill:
		check_terminate();
    n = read(ddc.inx.fd, ddc.inx.dbp + ddc.inx.dbrcnt, ddc.inx.dbsz - ddc.inx.dbrcnt);
		check_terminate();

		/* EOF */
    if (n == 0 && ddc.inx.dbrcnt == 0) {
      return;
    }

		/* Read error */
		if (n == -1) {
			/*
			 * If noerror not specified, die.  POSIX requires that
			 * the warning message be followed by an I/O display.
			 */
      if (!(ddflags & C_NOERROR)) {
        err(1, ddc.inx.name)
      }
      warn(ddc.inx.name)
			summary();

			/*
			 * If it's a seekable file descriptor, seek past the
			 * error.  If your OS doesn't do the right thing for
			 * raw disks this section should be modified to re-read
			 * in sector size chunks.
			 */
      if (ddc.inx.flags.contains(.ISSEEK) &&
          0 != lseek(ddc.inx.fd.rawValue, Int64(ddc.inx.dbsz), SEEK_CUR)) {
        warn(ddc.inx.name);
      }

			/* If sync not specified, omit block and continue. */
      if (!ddc.ddflags.contains(.C_SYNC)) {
        continue;
      }
		}

		/* If conv=sync, use the entire block. */
    if ddc.ddflags.contains(.C_SYNC) {
      n = ddc.inx.dbsz;
    }

		/* Count the bytes read for this block. */
    ddc.inx.dbrcnt += n;

		/* Count the number of full and partial blocks. */
    if (in.dbrcnt == in.dbsz) {
      ++st.in_full;
    }
    else if (ddflags & C_IFULLBLOCK && n != 0) {
      goto fill; /* these don't count */
    }
    else {
      ++st.in_part;
    }

		/* Count the total bytes read for this file. */
    ddc.inx.dbcnt += ddc.inx.dbrcnt;

		/*
		 * POSIX states that if bs is set and no other conversions
		 * than noerror, notrunc or sync are specified, the block
		 * is output without buffering as it is read.
		 */
		if ((ddflags & ~(C_NOERROR | C_NOTRUNC | C_SYNC)) == C_BS) {
			out.dbcnt = in.dbcnt;
			dd_out(1);
      ddc.inx.dbcnt = 0;
			continue;
		}

    if ddc.ddflags.contains(.C_SWAB) {
      if ((n = ddc.inx.dbrcnt) & 1) {
				++st.swab;
				--n;
			}
      swapbytes(ddc.inx.dbp, (size_t)n);
		}

		/* Advance to the next block. */
    ddc.inx.dbp += ddc.inx.dbrcnt;
    ddc.cfunc(&ddc)
    if (need_summary) {
      summary();
    }
    if (need_progress) {
      progress();
    }
	}
}

/*
 * Clean up any remaining I/O and flush output.  If necessary, the output file
 * is truncated.
 */
  func dd_close(_ ddc : inout DDContext) {
    if (ddc.cfunc == def) {
    def_close(&ddc)
  }
  else if (cfunc == block) {
    block_close();
  }
  else if (cfunc == unblock) {
    unblock_close();
  }

    if (ddc.ddflags.contains(.C_OSYNC) && 0 != ddc.out.dbcnt && ddc.out.dbcnt < ddc.out.dbsz) {
      if ddc.ddflags.contains(.C_FILL) {
        memset(ddc.out.dbp, fill_char, ddc.out.dbsz - ddc.out.dbcnt)
    }
      else if ddc.ddflags.contains([.C_BLOCK, .C_UNBLOCK]) {
        memset(ddc.out.dbp, ' ', ddc.out.dbsz - ddc.out.dbcnt);
    }
    else {
      memset(ddc.out.dbp, 0, ddc.out.dbsz - ddc.out.dbcnt);
    }
      ddc.out.dbcnt = ddc.out.dbsz;
	}
    if (ddc.out.dbcnt || pending) {
      dd_out(1);
    }

	/*
	 * If the file ends with a hole, ftruncate it to extend its size
	 * up to the end of the hole (without having to write any data).
	 */
	if (out.seek_offset > 0 && (out.flags & ISTRUNC)) {
    if (ftruncate(out.fd, out.seek_offset) == -1) {
      err(1, "truncating %s", out.name);
    }
	}

    if ddc.ddflags.contains(.C_FSYNC) {
      if (fsync(ddc.out.fd) == -1) {
        err(1, "fsyncing %s", ddc.out.name);
    }
/*#ifndef __APPLE__
	} else if (ddflags & C_FDATASYNC) {
    if (fdatasync(out.fd) == -1) {
      err(1, "fdatasyncing %s", out.name);
    }
#endif
 */
	}
}

  func dd_out(_ force : Bool, _ ddc : inout DDContext) {
//	u_char *outp;
//	size_t cnt, n;
//	ssize_t nw;
//	static int warned;
//	int sparse;

	/*
	 * Write one or more blocks out.  The common case is writing a full
	 * output block in a single write; increment the full block stats.
	 * Otherwise, we're into partial block writes.  If a partial write,
	 * and it's a character device, just warn.  If a tape device, quit.
	 *
	 * The partial writes represent two cases.  1: Where the input block
	 * was less than expected so the output block was less than expected.
	 * 2: Where the input block was the right size but we were forced to
	 * write the block in multiple chunks.  The original versions of dd(1)
	 * never wrote a block in more than a single write, so the latter case
	 * never happened.
	 *
	 * One special case is if we're forced to do the write -- in that case
	 * we play games with the buffer size, and it's usually a partial write.
	 */
	outp = out.db;

	/*
	 * If force, first try to write all pending data, else try to write
	 * just one block. Subsequently always write data one full block at
	 * a time at most.
	 */
	for (n = force ? out.dbcnt : out.dbsz;; n = out.dbsz) {
		cnt = n;
		do {
			sparse = 0;
			if (ddflags & C_SPARSE) {
				/* Is buffer sparse? */
				sparse = BISZERO(outp, cnt);
			}
			if (sparse && !force) {
				pending += cnt;
				nw = cnt;
			} else {
				if (pending != 0) {
					/*
					 * Seek past hole.  Note that we need to record the
					 * reached offset, because we might have no more data
					 * to write, in which case we'll need to call
					 * ftruncate to extend the file size.
					 */
					out.seek_offset = lseek(out.fd, pending, SEEK_CUR);
          if (out.seek_offset == -1) {
            err(2, "%s: seek error creating sparse file",
                out.name);
          }
					pending = 0;
				}
				if (cnt) {
					check_terminate();
					nw = write(out.fd, outp, cnt);
					check_terminate();
					out.seek_offset = 0;
				} else {
					return;
				}
			}

			if (nw <= 0) {
				if (nw == 0)
					errx(1, "%s: end of device", out.name);
        if (errno != EINTR) {
          err(1, "%s", out.name);
        }
				nw = 0;
			}

			outp += nw;
			st.bytes += nw;

      if ((size_t)nw == n && n == (size_t)out.dbsz) {
        ++st.out_full
      }
      else {
        ++st.out_part
      }

			if ((size_t) nw != cnt) {
        if (out.flags & ISTAPE) {
          errx(1, "%s: short write on tape device",
               out.name);
        }
				if (out.flags & ISCHR && !warned) {
					warned = 1;
					warnx("%s: short write on character device",
				    	out.name);
				}
			}

			cnt -= nw;
		} while (cnt != 0);

    if ((out.dbcnt -= n) < out.dbsz) {
      break;
    }
	}

	/* Reassemble the output block. */
  if 0 != ddc.out.dbcnt {
    (void)memmove(ddc.out.db, ddc.out.dbp - ddc.out.dbcnt, ddc.out.dbcnt)
  }
  ddc.out.dbp = ddc.out.db + ddc.out.dbcnt;
}
