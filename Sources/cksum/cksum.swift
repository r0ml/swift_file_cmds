// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * James W. Williams of NASA Goddard Space Flight Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Darwin

@main struct cksum : ShellCommand {
  //	uint32_t val;
  //	int ch, fd, rval;
  //	off_t len;
  //	char *fn, *p;
  //	int (*cfncn)(int, uint32_t *, off_t *);
  //	void (*pfncn)(char *, uint32_t, off_t);


  struct CommandOptions {
    var cfncn : (Int32) -> (UInt32, Int)? = crc
    var pfncn : (String?, UInt32, Int) -> () = pcrc
    var args : [String] = []
  }

  var options : CommandOptions!

  /*
  if ((p = strrchr(argv[0], '/')) == NULL)
    p = argv[0];
  else
    ++p;
*/

  func parseOptions() throws(CmdErr) -> CommandOptions {
/*    if (!strcmp(p, "sum")) {
      cfncn = csum1;
      pfncn = psum1;
      ++argv;
    } else {
 */
    var options = CommandOptions()
    var go = BSDGetopt("o:")
    while let (k,v) = try go.getopt() {
      switch k {
        case "o":
          switch v {
            case "1":
              options.cfncn = csum1
              options.pfncn = psum1
            case "2":
              options.cfncn = csum2
              options.pfncn = psum2
            case "3":
              options.cfncn = crc32
              options.pfncn = pcrc
            default:
              warn("illegal argument to -o option")
              throw CmdErr(1)
          }
        case "?":
          fallthrough
        default:
          throw CmdErr(1)
      }
    }
    options.args = go.remaining
    return options
  }

  func runCommand() throws(CmdErr) {
    var rval : Int32 = 0
    if options.args.isEmpty {
      let fd = STDIN_FILENO
      let fn : String? = nil
      if let vl = options.cfncn(fd) {
        options.pfncn(fn, vl.0, vl.1)
      } else {
        warn(fn ?? "stdin")
        rval = 1
      }
    }

    for fn in options.args {
      let fd = open(fn, O_RDONLY, 0)
        if fd < 0 {
          warn(fn)
          rval = 1
          continue
        }

    if let vl = options.cfncn(fd) {
      options.pfncn(fn, vl.0, vl.1)
    } else {
        warn(fn)
        rval = 1
      }
      close(fd)
    }
//    #ifdef __APPLE__
//    if (rval == 0 && (ferror(stdout) != 0 || fflush(stdout) != 0)) {
//      err(1, "stdout")
//    }
//#endif
    exit(rval)
  }

  var usage = """
usage: cksum [-o 1 | 2 | 3] [file ...]
       sum [file ...]
"""
}
