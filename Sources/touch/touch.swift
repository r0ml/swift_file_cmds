// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Darwin

@main struct touch : ShellCommand {

  struct CommandOptions {
    var ts = (timespec(), timespec())
    var atflag = false
    var Aflag = 0
    var aflag = false
    var cflag = false
    var mflag = false
    var timese = false
    var args : [String] = []
    var timeset = false
  }

  // ch, fd, len, rval, timeset;
  //	char *p;
  //	char *myname;

  //	myname = basename(argv[0]);

  var options : CommandOptions!

  func parseOptions() async throws(CmdErr) -> CommandOptions {
    var options = CommandOptions()

    options.ts.0.tv_sec = 0
    options.ts.1.tv_sec = 0
    options.ts.0.tv_nsec = Int(UTIME_NOW)
    options.ts.1.tv_nsec = Int(UTIME_NOW)

    let go = BSDGetopt("A:acd:fhmr:t:")
    while let (k,v) = try go.getopt() {
      switch k {
        case "A":
          options.Aflag = Int(timeoffset(v))
        case "a":
          options.aflag = true
        case "c":
          options.cflag = true
        case "d":
          options.timeset = true
          options.ts = stime_darg(v);
        case "f":
          /* No-op for compatibility. */
          break;
        case "h":
          options.cflag = true
          options.atflag = AT_SYMLINK_NOFOLLOW != 0
        case "m":
          options.mflag = true
        case "r":
          options.timeset = true
          options.ts = stime_file(v)
        case "t":
          options.timeset = true
          options.ts = stime_arg1(v)
        default:
          throw CmdErr(1)
      }
    }
    options.args = go.remaining

    if !options.aflag && !options.mflag {
      options.aflag = true
      options.mflag = true
    }

    if options.timeset {
      if options.Aflag != 0 {
        /*
         * We're setting the time to an offset from a specified
         * time.  God knows why, but it means that we can set
         * that time once and for all here.
         */
        if options.aflag {
          options.ts.0.tv_sec += options.Aflag
        }
        if options.mflag {
          options.ts.1.tv_sec += options.Aflag
        }
        options.Aflag = 0		/* done our job */
      }
    } else {
      /*
       * If no -r or -t flag, at least two operands, the first of
       * which is an 8 or 10 digit number, use the obsolete time
       * specification, otherwise use the current time.
       */
      if options.args.count > 1 {
        let p = options.args[0].prefix { $0.isNumber }
        if p.count == 8 || p.count == 10 {
          options.timeset = true
          options.ts = stime_arg2(String(p), p.count == 10)
          options.args.removeFirst()
        }
      }
      /* Both times default to the same. */
      options.ts.1 = options.ts.0
    }

    if !options.aflag {
      options.ts.0.tv_nsec = Int(UTIME_OMIT)
    }
    if !options.mflag {
      options.ts.1.tv_nsec = Int(UTIME_OMIT)
    }

    if options.args.isEmpty {
      throw CmdErr(1)
    }

    if options.Aflag != 0 {
      options.cflag = true
    }
    return options
  }

  var DEFFILEMODE = (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)

  func runCommand() async throws(CmdErr) {
    var rval : Int32 = 0
    var sb = stat()
    for argv in options.args {
      /* See if the file exists. */
      if (fstatat(AT_FDCWD, argv, &sb, options.atflag ? 1 : 0) != 0) {
        if (errno != ENOENT) {
          rval = 1;
          warn(argv)
          continue;
        }
        if !options.cflag {

          /* Create the file. */
          let fd = open(argv, O_WRONLY | O_CREAT, DEFFILEMODE);

          /*
           * See rdar://problem/69195889 -- don't leak
           * fd on failure.
           */
          let cfail = fd == -1 || fstat(fd, &sb) != 0;
          if fd != -1 {
            close(fd)
          }
          if cfail {
            rval = 1;
            warn(argv);
            continue;
          }

          /* If using the current time, we're done. */
          if (!options.timeset) {
            continue;
          }
        } else {
          continue
        }
      }

      var ts = options.ts

      /*
       * We're adjusting the times based on the file times, not a
       * specified time (that gets handled above).
       */
      if options.Aflag != 0 {
        if options.aflag {
          ts.0 = sb.st_atim
          ts.0.tv_sec += options.Aflag
        }
        if options.mflag {
          ts.1 = sb.st_mtim
          ts.1.tv_sec += options.Aflag
        }
      }

      if utimensat(AT_FDCWD, argv, &ts.0, options.atflag ? 1 : 0) == 0 {
        continue;
      }

      rval = 1;
      warn(argv)
    }
    exit(rval);
  }

  func ATOI2(_ ar : inout String) -> Int32 {
    let k = Int32(ar.prefix(2))
    ar.removeFirst(2)
    return k ?? 0
  }

  //    #define	ATOI2(ar)	((ar)[0] - '0') * 10 + ((ar)[1] - '0'); (ar) += 2;

  func stime_arg1(_ argx : String) -> (timespec, timespec) {
//    time_t now;
//    struct tm *t;
//    char *p;
    var yearset : Int32 = 0
    var arg = argx
    var now = time(nil)
    var tvp = (timespec(), timespec())
    var tt = localtime(&now)
    if tt == nil {
      err(1, "localtime")
    }

    var t = tt!.pointee

    /* [[CC]YY]MMDDhhmm[.SS] */

    t.tm_sec = 0
    if let p = arg.firstIndex(of: ".") {
      var pp = String(arg[arg.index(after: p)...])
      if pp.count == 2 {
        t.tm_sec = ATOI2(&pp)
        arg = String(arg[..<p])
      } else {
        errx(1, "out of range or illegal time specification: [[CC]YY]MMDDhhmm[.SS]");
      }
    }
    yearset = 0
    switch(arg.count) {
      case 12:			/* CCYYMMDDhhmm */
        t.tm_year = ATOI2(&arg)
        t.tm_year *= 100
        yearset = 1
        fallthrough
      case 10:			/* YYMMDDhhmm */
        if yearset != 0 {
          yearset = ATOI2(&arg)
          t.tm_year += yearset
        } else {
          yearset = ATOI2(&arg)
          if yearset < 69 {
            t.tm_year = yearset + 2000
          }
          else {
            t.tm_year = yearset + 1900
          }
        }
        t.tm_year -= 1900	/* Convert to UNIX time. */
        fallthrough
      case 8:				/* MMDDhhmm */
        t.tm_mon = ATOI2(&arg)
        t.tm_mon -= 1		/* Convert from 01-12 to 00-11 */
        t.tm_mday = ATOI2(&arg);
        t.tm_hour = ATOI2(&arg);
        t.tm_min = ATOI2(&arg);
      default:
        errx(1, "out of range or illegal time specification: [[CC]YY]MMDDhhmm[.SS]");
    }

    t.tm_isdst = -1		/* Figure out DST. */
    tvp.0.tv_sec = mktime(&t)
    tvp.1.tv_sec = tvp.0.tv_sec
    /// Ha Ha Ha -- the tests use a time which is -1 -- registers as an error
    if tvp.0.tv_sec != -1 {
      tvp.0.tv_nsec = 0
      tvp.1.tv_nsec = 0
      return tvp
    }
    errx(1, "out of range or illegal time specification: [[CC]YY]MMDDhhmm[.SS]")
    return tvp
  }

  func stime_arg2(_ argx : String, _ year : Bool) -> (timespec, timespec) {
//    time_t now;
//    struct tm *t;
    var arg = argx
    var now = time(nil)
    var tt = localtime(&now)
    var tvp = (timespec(), timespec() )

    if tt == nil {
      err(1, "localtime");
    }
    var t = tt!.pointee
    t.tm_mon = ATOI2(&arg)		/* MMDDhhmm[yy] */
    t.tm_mon -= 1			/* Convert from 01-12 to 00-11 */
    t.tm_mday = ATOI2(&arg)
    t.tm_hour = ATOI2(&arg)
    t.tm_min = ATOI2(&arg)
    if year {
      t.tm_year = ATOI2(&arg)
      if t.tm_year < 39	{ /* support 2000-2038 not 1902-1969 */
        t.tm_year += 100
      }
    }

    t.tm_isdst = -1		/* Figure out DST. */
    tvp.0.tv_sec = mktime(&t)
    tvp.1.tv_sec = tvp.0.tv_sec
    if tvp.0.tv_sec == -1 {
      errx(1, "out of range or illegal time specification: MMDDhhmm[yy]")
    }

    tvp.0.tv_nsec = 0
    tvp.1.tv_nsec = 0
    return tvp
  }

  func stime_darg(_ arg : String) -> (timespec, timespec) {
    var t = tm()
    t.tm_sec = 0

//    const char *fmt, *colon;
//    char *p;
//    int val, isutc = 0;

    var isutc = false
    var tvp = (timespec(), timespec() )
    tvp.0.tv_nsec = 0
    t.tm_isdst = -1
    let colon = arg.firstIndex(of: ":")
    if !(colon == nil || arg[arg.index(after: colon!)...].firstIndex(of: ":") == nil) {
      let fmt = arg.firstIndex(of: "T") != nil ? "%Y-%m-%dT%H:%M:%S" :
      "%Y-%m-%d %H:%M:%S";
      let p = strptime(arg, fmt, &t)
      if let p {
        /* POSIX: must have at least one digit after dot */
        var pp = String(cString: p)
        if pp.hasPrefix(".") || pp.hasPrefix(",") {
          pp.removeFirst()
          let zz = pp.prefix { $0.isNumber }
          if !zz.isEmpty, let kk = Double("0."+zz) {
              tvp.0.tv_nsec = Int(kk * 1_000_000_000)
          } else {
            errx(1, "out of range or illegal time specification: YYYY-MM-DDThh:mm:SS[.frac][tz]");
          }
        }
        if arg.hasSuffix("Z") {
          isutc = true
        }
        if pp.isEmpty {
          tvp.0.tv_sec = isutc ? timegm(&t) : mktime(&t);
          tvp.1 = tvp.0
          return tvp
        }
      }
    }
//  bad:
    errx(1, "out of range or illegal time specification: YYYY-MM-DDThh:mm:SS[.frac][tz]");
    return tvp
  }

  /* Calculate a time offset in seconds, given an arg of the format [-]HHMMSS. */
  func timeoffset(_ argx : String) -> Int32 {
    var arg = argx
    var offset : Int32 = 0
    let isneg = arg.hasPrefix("-")
    if isneg {
      arg.removeFirst()
    }
    switch arg.count {

      case 6:					/* HHMMSS */
        offset = ATOI2(&arg)
        fallthrough
      case 4:					/* MMSS */
        offset = offset * 60 + ATOI2(&arg)
        fallthrough
      case 2:					/* SS */
        offset = offset * 60 + ATOI2(&arg)

      default:        /* invalid */
        errx(1, "Invalid offset spec, must be [-][[HH]MM]SS");
    }
    return isneg ? -offset : offset
  }

  func stime_file(_ fname : String) -> (timespec, timespec) {
    var sb = stat()
    if stat(fname, &sb) < 0 {
      err(1, fname)
    }
    return (sb.st_atim, sb.st_mtim)
  }

  var usage : String { get { """
usage: \(programName) [-A [-][[hh]mm]SS] [-achm] [-r file] [-t [[CC]YY]MMDDhhmm[.SS]]
                      [-d YYYY-MM-DDThh:mm:SS[.frac][tz]] file ...
"""
  }
  }
}
