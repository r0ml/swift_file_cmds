// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1980, 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Darwin

let unix2003 = true

@main struct df : ShellCommand {


  // #ifdef __APPLE__
  let MNT_IGNORE = 0
  // #endif /* defined(__APPLE__) */

  let UNITS_SI = 1
  let UNITS_2 = 2

  /* Maximum widths of various fields. */
  struct maxwidths {
    var	mntfrom = 0
    var fstype = 0
    var total = 0
    var used = 0
    var avail = 0
    var iused = 0
    var ifree = 0
  };

  /*
   func imax(int a, int b) -> Int {
   return (a > b ? a : b);
   }
   */

  struct CommandOptions {
    var aflag = false
    var cflag = false
    var hflag = 0
    var iflag = false
    var kflag = 0
    var lflag = false
    var nflag = false
    var Tflag = false
    var kludge_tflag = false
    var thousands = false
    var args = [String]()
  }

  var options : CommandOptions!

  // static int	  thousands;
  // static int	  skipvfs_l, skipvfs_t;
  // static const char **vfslist_l, **vfslist_t;

  var long_options : [CMigration.option] = [
    option("si", .no_argument),
  ]

  func parseOptions() throws(CmdErr) -> CommandOptions {
    /*	struct stat stbuf;
     struct statfs statfsbuf, totalbuf;
     struct maxwidths maxwidths;
     struct statfs *mntbuf;
     char *mntpt;
     int i, mntsize;
     int ch, rv;
     int kludge_tflag = 0;
     const char *options = "+abcgHhIiklmnPt:T:Y,";
     unix2003_compat = COMPAT_MODE("bin/df", "unix2003");
     */

    var options = CommandOptions()

    var gopts = "+abcgHhIiklmnPt:T:Y,"
    if unix2003 {
      /* Unix2003 requires -t be "include total capacity". which df
       already does, but it conflicts with the old -t so we need to
       *not* expect a string after -t (we provide -T in both cases
       to cover the old use of -t) */
      gopts = "+abcgHhIiklmnPtT:Y,"
      options.iflag = true
    }
    var go = BSDGetopt_long(gopts, long_options)


    /*	memset(&maxwidths, 0, sizeof(maxwidths));
     memset(&totalbuf, 0, sizeof(totalbuf));
     totalbuf.f_bsize = DEV_BSIZE;
     strlcpy(totalbuf.f_mntfromname, "total", MNAMELEN);
     */

    /*
     argc = xo_parse_args(argc, argv);
     if (argc < 0)
     exit(1);
     */

    while let (k,v) = try go.getopt_long() {
      switch k {
        case "a":
          options.aflag = true
        case "b", "P":
          if unix2003 {
            options.iflag = false
          }
          /*
           * POSIX specifically discusses the behavior of
           * both -k and -P. It states that the blocksize should
           * be set to 1024. Thus, if this occurs, simply break
           * rather than clobbering the old blocksize.
           */
          if options.kflag != 0 {
            break
          }
          setenv("BLOCKSIZE", "512", 1);
          options.hflag = 0
        case "c":
          options.cflag = true
        case "g":
          setenv("BLOCKSIZE", "1g", 1);
          options.hflag = 0
        case "H", "si":
          options.hflag = UNITS_SI
        case "h":
          options.hflag = UNITS_2
        case "I":
          options.iflag = false
        case "i":
          options.iflag = true
        case "k":
          options.kflag += 1;
          setenv("BLOCKSIZE", "1024", 1);
          options.hflag = 0
        case "l":
          /* Ignore duplicate -l */
          if options.lflag {
            break
          }
          vfslist_l = makevfslist(makenetvfslist(), &skipvfs_l);
          options.lflag = true
        case "m":
          setenv("BLOCKSIZE", "1m", 1);
          options.hflag = 0
        case "n":
          options.nflag = true
        case "t":
          /* Unix2003 uses -t for something we do by default */
          if unix2003 {
            options.kludge_tflag = true
          }
        case "T":
          if (vfslist_t != NULL) {
            xo_errx(1, "only one -%c option may be specified", ch);
          }
          vfslist_t = makevfslist(optarg, &skipvfs_t);
          break;
        case "Y":
          options.Tflag = true
        case ",":
          options.thousands = true
        case "?":
          fallthrough
        default:
          throw CmdErr(1)
      }
    }
    options.args = go.remaining

    /* If we are in unix2003 mode, have seen a -t but no -T and the first
     non switch arg isn't a file, let's pretend they used -T on it.
     This makes the Lexmark printer installer happy (PR-3918471) */
    if (vfslist_t == NULL && options.kludge_tflag && *argv &&
        stat(*argv, &stbuf) < 0 && errno == ENOENT) {
      vfslist_t = makevfslist(*argv++, &skipvfs_t);
    }
    return options
  }

  func runCommand() async throws(CmdErr) {
    rv = EXIT_SUCCESS;
    if (!*argv) {
      /* everything (modulo -t) */
      mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
      mntsize = regetmntinfo(&mntbuf, mntsize);
    } else {
      /* just the filesystems specified on the command line */
      mntbuf = malloc(argc * sizeof(*mntbuf));
      if (mntbuf == NULL)
          xo_err(1, "malloc()");
      mntsize = 0;
      /* continued in for loop below */
    }

    xo_open_container("storage-system-information");
    xo_open_list("filesystem");

    /* iterate through specified filesystems */
    for argv in options.args {
      if (stat(*argv, &stbuf) < 0) {
        if ((mntpt = getmntpt(*argv)) == NULL) {
          xo_warn("%s", *argv);
          rv = EXIT_FAILURE;
          continue;
        }
      } else if (S_ISCHR(stbuf.st_mode) || S_ISBLK(stbuf.st_mode)) {
        mntpt = getmntpt(*argv);
        if (mntpt == NULL) {
          xo_warnx("%s: not mounted", *argv);
          rv = EXIT_FAILURE;
          continue;
        }
      } else {
        mntpt = *argv;
      }

      /*
       * Statfs does not take a `wait' flag, so we cannot
       * implement nflag here.
       */
      if (statfs(mntpt, &statfsbuf) < 0) {
        xo_warn("%s", mntpt);
        rv = EXIT_FAILURE;
        continue;
      }

      /*
       * Check to make sure the arguments we've been given are
       * satisfied.  Return an error if we have been asked to
       * list a mount point that does not match the other args
       * we've been given (-l, -t, etc.).
       */
      if (checkvfsselected(statfsbuf.f_fstypename) != 0) {
        rv = EXIT_FAILURE;
        continue;
      }

      /* the user asked for it, so ignore the ignore flag */
      statfsbuf.f_flags &= ~MNT_IGNORE;

      /* add to list */
      mntbuf[mntsize++] = statfsbuf;
    }

    memset(&maxwidths, 0, sizeof(maxwidths));
    for i in 0..<mntsize {
      if (options.aflag || (mntbuf[i].f_flags & MNT_IGNORE) == 0) {
        update_maxwidths(&maxwidths, &mntbuf[i]);
        if options.cflag {
          addstat(&totalbuf, &mntbuf[i]);
        }
      }
    }
    for i in 0..<mntsize {
      if (options.aflag || (mntbuf[i].f_flags & MNT_IGNORE) == 0) {
        prtstat(&mntbuf[i], &maxwidths)
      }
    }

    xo_close_list("filesystem");

    if options.cflag {
      prtstat(&totalbuf, &maxwidths);
    }

    xo_close_container("storage-system-information");
    if (xo_finish() < 0) {
      xo_err(EXIT_FAILURE, "stdout")
    }
    exit(rv);
  }

  func getmntpt(_ name : String) -> String? {
    size_t mntsize, i;
    struct statfs *mntbuf;

    mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
    for (i = 0; i < mntsize; i++) {
      if (!strcmp(mntbuf[i].f_mntfromname, name))
          return (mntbuf[i].f_mntonname);
    }
    return nil
  }

  static const char **
  makevfslist(char *fslist, int *skip)
  {
    const char **av;
    int i;
    char *nextcp;

    if (fslist == NULL)
        return (NULL);
    *skip = 0;
    if (fslist[0] == 'n' && fslist[1] == 'o') {
      fslist += 2;
      *skip = 1;
    }
    for (i = 0, nextcp = fslist; *nextcp; nextcp++)
          if (*nextcp == ',')
          i++;
    if ((av = malloc((size_t)(i + 2) * sizeof(char *))) == NULL) {
      xo_warnx("malloc failed");
      return (NULL);
    }
    nextcp = fslist;
    i = 0;
    av[i++] = nextcp;
    while ((nextcp = strchr(nextcp, ',')) != NULL) {
      *nextcp++ = '\0';
      av[i++] = nextcp;
    }
    av[i++] = NULL;
    return (av);
  }

  static int
  checkvfsname(const char *vfsname, const char **vfslist, int skip)
  {

    if (vfslist == NULL)
        return (0);
    while (*vfslist != NULL) {
      if (strcmp(vfsname, *vfslist) == 0)
          return (skip);
      ++vfslist;
    }
    return (!skip);
  }

  /*
   * Without -l and -t option, all file system types are enabled.
   * The -l option selects the local file systems, if present.
   * A -t option modifies the selection by adding or removing further
   * file system types, based on the argument that is passed.
   */
  static int
  checkvfsselected(char *fstypename)
  {
    int result;

    if (vfslist_t) {
      /* if -t option used then select passed types */
      result = checkvfsname(fstypename, vfslist_t, skipvfs_t);
      if (vfslist_l) {
        /* if -l option then adjust selection */
        if (checkvfsname(fstypename, vfslist_l, skipvfs_l) == skipvfs_t)
            result = skipvfs_t;
      }
    } else {
      /* no -t option then -l decides */
      result = checkvfsname(fstypename, vfslist_l, skipvfs_l);
    }
    return (result);
  }

  /*
   * Make a pass over the file system info in ``mntbuf'' filtering out
   * file system types not in vfslist_{l,t} and possibly re-stating to get
   * current (not cached) info.  Returns the new count of valid statfs bufs.
   */
    func regetmntinfo(struct statfs **mntbufp, long mntsize) -> Int {
    int error, i, j;
    struct statfs *mntbuf;

    if (vfslist_l == NULL && vfslist_t == NULL)
        return (nflag ? mntsize : getmntinfo(mntbufp, MNT_WAIT));

    mntbuf = *mntbufp;
    for (j = 0, i = 0; i < mntsize; i++) {
      if (checkvfsselected(mntbuf[i].f_fstypename) != 0)
          continue;
      /*
       * XXX statfs(2) can fail for various reasons. It may be
       * possible that the user does not have access to the
       * pathname, if this happens, we will fall back on
       * "stale" filesystem statistics.
       */
      error = statfs(mntbuf[i].f_mntonname, &mntbuf[j]);
      if (nflag || error < 0)
          if (i != j) {
        if (error < 0)
            xo_warnx("%s stats possibly stale",
                     mntbuf[i].f_mntonname);
        mntbuf[j] = mntbuf[i];
      }
      j++;
    }
    return (j);
  }

  func prthuman(_ sfsp : statfs, _ used : Int64) {
    prthumanval("  {:blocks/%6s}", Int(sfsp.f_blocks) * Int(sfsp.f_bsize))
    prthumanval("  {:used/%6s}", Int(used) * Int(sfsp.f_bsize))
    prthumanval("  {:available/%6s}", Int(sfsp.f_bavail) * Int(sfsp.f_bsize))
  }

  func prthumanval(_ fmt : String, _ bytes : Int) {
    /*#ifndef __APPLE__
     char buf[6];
     #else
     */
    // #endif

    var flags : HumanizeFlags = [.b, .nospace, .decimal]
    if (options.hflag == UNITS_SI) {
      flags.insert(.divisor_1000)
    }

    /*
     #ifndef __APPLE__
     humanize_number(buf, sizeof(buf) - (bytes < 0 ? 0 : 1),
     bytes, "", HN_AUTOSCALE, flags);
     #else
     */
    let buf = humanize_number(7 - (bytes < 0 ? 0 : 1),
                              bytes, options.hflag == UNITS_SI ? "" : "i", nil, flags)
    // #endif

    xo_attr("value", "%lld", (long long) bytes);
    xo_emit(fmt, buf);
  }

  /*
   * Print an inode count in "human-readable" format.
   */
  func prthumanvalinode(_ fmt : String, _ bytes : Int) {
    var flags : HumanizeFlags = [.nospace, .decimal, .divisor_1000]

    let buf = humanize_number(6 - (bytes < 0 ? 0 : 1), bytes, "", nil, flags)

    xo_attr("value", "%lld", (long long) bytes);
    xo_emit(fmt, buf);
  }

  /*
   * Convert statfs returned file system size into BLOCKSIZE units.
   * Attempts to avoid overflow for large filesystems.
   */
  func fsbtoblk(_ num : Int, _ fsbs : Int, _ bs : Int, _ fs : String) -> Int {
    if (num < 0) {
      xo_warnx("negative filesystem block count/size from fs \(fs)")
      return 0
    } else if ((fsbs != 0) && (fsbs < bs)) {
      return (num / (bs / fsbs))
    } else {
      return (num * (fsbs / bs))
    }
  }

  func usedblks(_ sfsp : statfs) -> Int {

    /* Call getattrlist(ATTR_VOL_SPACEUSED) to get used space info. */
    struct {
      uint32_t size;
      uint64_t spaceused;
    } __attribute__((aligned(4), packed)) attrbuf = {0};
    struct attrlist attrs = {0};

    attrs.bitmapcount = ATTR_BIT_MAP_COUNT;
    attrs.volattr = ATTR_VOL_INFO | ATTR_VOL_SPACEUSED;
    if (getattrlist(sfsp.f_mntonname, &attrs, &attrbuf, sizeof(attrbuf), 0) != 0) {
      if (errno != EINVAL) {
        xo_warn("getattrlist failed for \(sfsp.f_mntonname)")
      }
      return Int(sfsp.f_blocks - sfsp.f_bfree)
    }

    /* The structure passed isn't entirely filled out -
     but use the preferred default value. */
    if (sfsp.f_bsize == 0) {
      return attrbuf.spaceused / blocksize;
    }

    return attrbuf.spaceused / sfsp.f_bsize
  }

  /*
   * Print out status about a file system.
   */
  func prtstat(_ sfsp : inout statfs, _ mwp : inout maxwidths) {
/*    static long blocksize;
    static int headerlen, timesthrough = 0;
    static const char *header;
    int64_t used, availblks, inodes;
    const char *format;
    const char *avail_str;
*/
    if (++timesthrough == 1) {
      mwp.mntfrom = max(mwp.mntfrom, strlen("Filesystem"))
      mwp.fstype = max(mwp.fstype, strlen("Type"))
      if (options.thousands) {		/* make space for commas */
        mwp.total += (mwp.total - 1) / 3;
        mwp.used  += (mwp.used - 1) / 3;
        mwp.avail += (mwp.avail - 1) / 3;
        mwp.iused += (mwp.iused - 1) / 3;
        mwp.ifree += (mwp.ifree - 1) / 3;
      }
      if options.hflag {
        header = "   Size";
        mwp.total = mwp.used = mwp.avail = strlen(header)
      } else {
        header = getbsize(&headerlen, &blocksize)
        mwp.total = max(mwp.total, headerlen)
      }
      mwp.used = max(mwp.used, strlen("Used"))
      if unix2003 && !options.hflag) {
        avail_str = "Available"
      } else {
        avail_str = "Avail"
      }
      mwp.avail = max(mwp.avail, strlen(avail_str))

      xo_emit("{T:/%-*s}", mwp.mntfrom, "Filesystem");
      if options.Tflag {
        xo_emit("  {T:/%-*s}", mwp.fstype, "Type")
      }
      xo_emit(" {T:/%*s} {T:/%*s} {T:/%*s} {T:Capacity}",
              mwp.total, header,
              mwp.used, "Used",
              mwp.avail, avail_str)
      if options.iflag {
        mwp.iused = max(options.hflag != 0 ? 0 : mwp.iused, strlen("  iused"))
        mwp.ifree = max(options.hflag != 0 ? 0 : mwp.ifree, strlen("ifree"))
        xo_emit(" {T:/%*s} {T:/%*s} {T:\%iused}",
                mwp.iused - 2, "iused", mwp.ifree, "ifree")
      }
      xo_emit("  {T:Mounted on}\n");
    }

    xo_open_instance("filesystem");
    /* Check for 0 block size.  Can this happen? */
    if (sfsp.f_bsize == 0) {
      xo_warnx ("File system \(sfsp.f_mntonname) does not have a block size, assuming 512.")
      sfsp.f_bsize = 512
    }
    xo_emit("{tk:name/%-*s}", mwp->mntfrom, sfsp->f_mntfromname);
    if (Tflag)
        xo_emit("  {:type/%-*s}", mwp->fstype, sfsp->f_fstypename);
    if (sfsp.f_blocks > sfsp.f_bfree) {
      used = usedblks(sfsp)
    } else {
      used = 0
    }
    availblks = sfsp.f_bavail + used
    if options.hflag {
      prthuman(sfsp, used);
    } else {
      if options.thousands {
        format = " {t:total-blocks/%*j'd} {t:used-blocks/%*j'd} "
        "{t:available-blocks/%*j'd}"
      }
      else {
        format = " {t:total-blocks/%*jd} {t:used-blocks/%*jd} "
        "{t:available-blocks/%*jd}"
      }
      xo_emit(format,
              mwp->total, fsbtoblk(sfsp->f_blocks, sfsp->f_bsize, blocksize, sfsp->f_mntonname),
              mwp->used, fsbtoblk(used, sfsp->f_bsize, blocksize, sfsp->f_mntonname),
              mwp->avail, fsbtoblk(sfsp->f_bavail, sfsp->f_bsize, blocksize, sfsp->f_mntonname));
    }
    if unix2003 {
      /* Standard says percentage must be rounded UP to next
       integer value, not truncated */
      double value;
      if (availblks == 0)
          value = 100.0;
      else {
        value = (double)used / (double)availblks * 100.0;
        if ((value-(int)value) > 0.0) value = value + 1.0;
      }
      xo_emit(" {:used-percent/%5.0f}{U:%%}", trunc(value));
    } else {
      xo_emit(" {:used-percent/%5.0f}{U:%%}",
              availblks == 0 ? 100.0 : (double)used / (double)availblks * 100.0);
    }
    if options.iflag {
      inodes = sfsp->f_files;
      used = inodes - sfsp->f_ffree;
      if (hflag) {
        xo_emit("  ");
        prthumanvalinode(" {:inodes-used/%5s}", used);
        prthumanvalinode(" {:inodes-free/%5s}", sfsp->f_ffree);
      } else {
        if (thousands)
            format = " {:inodes-used/%*j'd} {:inodes-free/%*j'd}";
        else
          format = " {:inodes-used/%*jd} {:inodes-free/%*jd}";
        xo_emit(format, mwp->iused, (intmax_t)used,
                mwp->ifree, (intmax_t)sfsp->f_ffree);
      }
      if (inodes == 0)
          xo_emit(" {:inodes-used-percent/    -}{U:} ");
      else {
        xo_emit(" {:inodes-used-percent/%4.0f}{U:%%} ",
                (double)used / (double)inodes * 100.0);
      }
    } else
      xo_emit("  ");
    if (strncmp(sfsp->f_mntfromname, "total", MNAMELEN) != 0)
        xo_emit("  {:mounted-on}", sfsp->f_mntonname);
    xo_emit("\n");
    xo_close_instance("filesystem");
  }

  func addstat(_ totalfsp : inout statfs, _ statfsp : statfs) {
    let bsize = UInt64(statfsp.f_bsize / totalfsp.f_bsize)
    totalfsp.f_blocks += statfsp.f_blocks * bsize
    totalfsp.f_bfree += statfsp.f_bfree * bsize
    totalfsp.f_bavail += statfsp.f_bavail * bsize
    totalfsp.f_files += statfsp.f_files
    totalfsp.f_ffree += statfsp.f_ffree
  }

  var blocksize = {
    var dummy : Int32 = 0
    var bs : Int = 0
    Darwin.getbsize(&dummy, &bs)
    return bs
  }()

  /*
   * Update the maximum field-width information in `mwp' based on
   * the file system specified by `sfsp'.
   */
  func update_maxwidths(_ mwp : inout maxwidths, _ sfs : statfs) {
    var sfsp = sfs

    mwp.mntfrom = max(mwp.mntfrom, strlen(&sfsp.f_mntfromname))
    mwp.fstype = max(mwp.fstype, strlen(&sfsp.f_fstypename))
    mwp.total = max(mwp.total, int64width(
      fsbtoblk(sfsp.f_blocks, sfsp.f_bsize, blocksize, sfsp.f_mntonname)))
    mwp.used = max(mwp.used,
                     int64width(fsbtoblk(sfsp.f_blocks -
                                         sfsp.f_bfree, sfsp.f_bsize, blocksize, sfsp.f_mntonname)));
    mwp.avail = max(mwp.avail, int64width(fsbtoblk(sfsp.f_bavail,
                                                      sfsp.f_bsize, blocksize, sfsp.f_mntonname)));
    mwp.iused = max(mwp.iused, int64width(Int(sfsp.f_files - sfsp.f_ffree)))
    mwp.ifree = max(mwp.ifree, int64width(Int(sfsp.f_ffree)))
  }

  /* Return the width in characters of the specified value. */
  func int64width(_ valx : Int) -> Int {
    var len = 0
    var val = valx
    /* Negative or zero values require one extra digit. */
    if (val <= 0) {
      val = -val
      len += 1
    }
    while (val > 0) {
      len += 1
      val /= 10
    }

    return len
  }

  // FIXME: ??  --- what is this xo_error
  // 	xo_error(
  var usage = """
usage: df [--libxo] [-b | -g | -H | -h | -k | -m | -P] [-acIiln\(unix2003 ? "" : "t")] [-,] [-T type]\(unix2003 ? "[-t type]" : "")
          [file | filesystem ...]
"""

  func makenetvfslist() -> String {
    char *str, *strptr, **listptr;
    //    #ifdef __APPLE__
    struct vfsconf vfc;
    void *keep_xvfsp = NULL; /* to avoid special casing free() in non-Apple paths */
    int mib[4];
    /*
     #else /* !__APPLE__ */
     struct xvfsconf *xvfsp, *keep_xvfsp;
     #endif /* __APPLE__ */
     */
    size_t buflen;
    int cnt, i, maxvfsconf;

    //    #ifdef __APPLE__
    mib[0] = CTL_VFS; mib[1] = VFS_GENERIC; mib[2] = VFS_MAXTYPENUM;
    buflen = sizeof(maxvfsconf);
    if (sysctl(mib, 3, &maxvfsconf, &buflen, NULL, 0) != 0) {
      xo_warn("sysctl failed");
      return (NULL);
    }
    /* #else /* !__APPLE__ */
     if (sysctlbyname("vfs.conflist", NULL, &buflen, NULL, 0) < 0) {
     xo_warn("sysctl(vfs.conflist)");
     return (NULL);
     }
     xvfsp = malloc(buflen);
     if (xvfsp == NULL) {
     xo_warnx("malloc failed");
     return (NULL);
     }
     keep_xvfsp = xvfsp;
     if (sysctlbyname("vfs.conflist", xvfsp, &buflen, NULL, 0) < 0) {
     xo_warn("sysctl(vfs.conflist)");
     free(keep_xvfsp);
     return (NULL);
     }
     maxvfsconf = buflen / sizeof(struct xvfsconf);
     #endif /* __APPLE__ */
     */

    if ((listptr = malloc(sizeof(char*) * maxvfsconf)) == NULL) {
      xo_warnx("malloc failed");
      free(keep_xvfsp);
      return (NULL);
    }

    //    #ifdef __APPLE__
    buflen = sizeof(struct vfsconf);
    mib[2] = VFS_CONF;
    // #endif /* __APPLE__ */
    for (cnt = 0, i = 0; i < maxvfsconf; i++) {
      const char *name;
      //      #ifdef __APPLE__
      mib[3] = i;
      if (sysctl(mib, 4, &vfc, &buflen, NULL, 0) != 0) {
        if (errno != ENOTSUP)
            xo_warn("sysctl failed");
        continue;
      }
      if (!(vfc.vfc_flags & MNT_LOCAL)) {
        name = vfc.vfc_name;
        // #else /* !__APPLE__ */
        //        if (xvfsp->vfc_flags & VFCF_NETWORK) {
        //           name = xvfsp->vfc_name;
        // #endif /* __APPLE__ */
        listptr[cnt++] = strdup(name);
        if (listptr[cnt-1] == NULL) {
          xo_warnx("malloc failed");
          free(listptr);
          free(keep_xvfsp);
          return (NULL);
        }
      }
      /*        #ifndef __APPLE__
       xvfsp++;
       #endif /* !__APPLE__ */
       */      }

    if (cnt == 0 ||
        (str = malloc(sizeof(char) * (32 * cnt + cnt + 2))) == NULL) {
      if (cnt > 0)
          xo_warnx("malloc failed");
      free(listptr);
      free(keep_xvfsp);
      return (NULL);
    }

    *str = 'n'; *(str + 1) = 'o';
    for (i = 0, strptr = str + 2; i < cnt; i++, strptr++) {
      strlcpy(strptr, listptr[i], 32);
      strptr += strlen(listptr[i]);
      *strptr = ',';
      free(listptr[i]);
    }
    *(--strptr) = '\0';

    free(keep_xvfsp);
    free(listptr);
    return (str);
  }
}
