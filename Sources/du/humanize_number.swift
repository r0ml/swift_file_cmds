// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*  $NetBSD: humanize_number.c,v 1.14 2008/04/28 20:22:59 martin Exp $  */

/*-
 * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
 *
 * Copyright (c) 1997, 1998, 1999, 2002 The NetBSD Foundation, Inc.
 * Copyright 2013 John-Mark Gurney <jmg@FreeBSD.org>
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center, by Luke Mewburn and by Tomas Svensson.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/* Values for humanize_number(3)'s flags parameter. */
public struct HumanizeFlags : OptionSet {
  public let rawValue: Int

  public init(rawValue: Int) {
    self.rawValue = rawValue
  }
  public static let decimal = Self(rawValue: 1 << 0) // 1
  public static let nospace = Self(rawValue: 1 << 1) // 2
  public static let b = Self(rawValue: 1 << 2) // 4
  public static let divisor_1000 = Self(rawValue: 1 << 3) // 8
  public static let iec_prefixes = Self(rawValue: 1 << 4) // 0x10
}

fileprivate typealias HFS = (divisor: Int, scale: Int, divisordeccut : Int)
fileprivate let maxscale = 6

public func humanize_number(_ len : Int, _ quotientx : Int, _ suffix : String, _ scale : UInt?, _ flags : HumanizeFlags) -> String? {
  var scx : Int
  if let sx = gshn(len, quotientx, suffix, flags) {
    if let scale {
      if scale > maxscale { return nil }
      scx = Int(scale)
    } else {
      scx = sx
    }
    return hn(len, quotientx, suffix, scx, flags)
  } else {
    return nil
  }
}

/// get scale for humanize_number, or fail with nil
fileprivate func gshn(_ len : Int, _ quotientx : Int, _ suffix : String, _ flags : HumanizeFlags) -> Int? {
  /* Values for humanize_number(3)'s scale parameter. */
  let getscale = 1 << 4 // 0x10
  let autoscale = 1 << 5 // 0x20



  /*
   const char *prefixes, *sep;
   int  i, r, remainder, s1, s2, sign;
   int  divisordeccut;
   int64_t  divisor, max;
   size_t  baselen;
   */

  var quotient = quotientx

  if flags.contains(.divisor_1000) && flags.contains(.iec_prefixes) {
    return nil
  }

  /* setup parameters */

  var (divisor, divisordeccut, _, baselen) = gp(flags, 0)

  if quotient < 0 {
    quotient = -quotient
    baselen += 2    /* sign, digit */
  } else {
    baselen += 1    /* digit */
  }
  if flags.contains(.nospace) {
  } else {
    baselen += 1
  }
  baselen += suffix.count

  if len < baselen + 1 {
    return nil
  }

  var ii = len - baselen

  // what follows calculates scale -- but not necessary if scale provided
  //  if (scale & (HN_AUTOSCALE | HN_GETSCALE)) {
  var max = 1
  /* See if there is additional columns can be used. */
  while ii > 0 && max <= Int.max / 10 {
    ii -= 1
    max *= 10
  }

  var remainder = 0
  var i = 0
  /*
   * Divide the number until it fits the given column.
   * If there will be an overflow by the rounding below,
   * divide once more.
   */
   while
       (quotient >= max || (quotient == max - 1 &&
                            (remainder >= divisordeccut || remainder >=
                             divisor / 2))) && i < maxscale {
    remainder = quotient % divisor;
    quotient /= divisor;
     i += 1
  }

  // This is the calculated scale
  return i
}

fileprivate typealias GP = (divisor: Int, divisordeccut: Int, prefix: String, baselen : Int)

fileprivate func gp(_ flags: HumanizeFlags, _ scale : Int) -> GP {
  var prefixes : [String]
  var divisor : Int
  var divisordeccut : Int

  func scale2prefix(_ scale : Int) -> String {
    prefixes[scale]
  }

  var baselen : Int

  if flags.contains(.iec_prefixes) {
    /*
     * Use the prefixes for power of two recommended by
     * the International Electrotechnical Commission
     * (IEC) in IEC 80000-3 (i.e. Ki, Mi, Gi...).
     *
     * HN_IEC_PREFIXES implies a divisor of 1024 here
     * (use of HN_DIVISOR_1000 would have triggered
     * an assertion earlier).
     */
    baselen = 2
    divisor = 1024
    divisordeccut = 973  /* ceil(.95 * 1024) */
    if flags.contains(.b) {
      prefixes = ["B", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei"]
    }
    else {
      prefixes = ["", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei"]
    }
  } else {
    baselen = 1
    if flags.contains(.divisor_1000) {
      divisor = 1000
      divisordeccut = 950
      if flags.contains(.b) {
        prefixes = ["B", "k", "M", "G", "T", "P", "E"]
      } else {
        prefixes = ["", "k", "M", "G", "T", "P", "E"]
      }
    } else {
      divisor = 1024
      divisordeccut = 973  /* ceil(.95 * 1024) */
      if flags.contains(.b) {
        prefixes = ["B", "K", "M", "G", "T", "P", "E"]
      } else {
        prefixes = ["", "K", "M", "G", "T", "P", "E"]
      }
    }
  }
  return (divisor: divisor, divisordeccut: divisordeccut, prefix: scale2prefix(scale), baselen: baselen)

}

import locale_h

fileprivate func hn(_ len : Int, _ quotientx : Int, _ suffix : String, _ scale : Int, _ flags : HumanizeFlags) -> String? {

  var quotient = quotientx
  var remainder = 0
  var (divisor, divisordeccut, prefix, _) = gp(flags, scale)



  var sign : Int
  var sep : String

  if quotient < 0 {
    sign = -1
    quotient = -quotient
  } else {
    sign = 1;
  }
  if flags.contains(.nospace) {
    sep = ""
  } else {
    sep = " ";
  }


  for i in 0..<scale {
    remainder = quotient % divisor;
    quotient /= divisor;
  }

  var i = scale

  /* If a value <= 9.9 after rounding and ... */
  /*
   * XXX - should we make sure there is enough space for the decimal
   * place and if not, don't do HN_DECIMAL?
   */
  if ((quotient == 9 && remainder < divisordeccut) || quotient < 9) &&
      i > 0 && flags.contains(.decimal) {
    let s1 = quotient + ((remainder * 10 + divisor / 2) / divisor / 10)
    let s2 = ((remainder * 10 + divisor / 2) / divisor) % 10
    var dd : String = "."
    if let decpt = localeconv()?.pointee.decimal_point.pointee {
      dd = String(decpt)
    }

    return "\(sign * s1)\(dd)\(s2)\(sep)\(prefix)\(suffix)"
  } else {
    return  "\(sign * (quotient + (remainder + divisor / 2) / divisor))\(sep)\(prefix)\(suffix)"
  }
}
