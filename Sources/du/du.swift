// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Newcomb.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Darwin

let SI_OPT = CHAR_MAX + 1
let UNITS_2 = 1
let UNITS_SI = 2

let unix2003 = true


/*
typedef struct _compat_ftsent {
	struct _ftsent *fts_cycle;	/* cycle node */
	struct _ftsent *fts_parent;	/* parent directory */
	struct _ftsent *fts_link;	/* next file in directory */
        union {
                struct {
                        long __fts_number;      /* local numeric value */
                        void *__fts_pointer;    /* local address value */
                } __struct_ftsent;
// rdar://78464191
#if TARGET_OS_WATCH
                int32_t __fts_bignum;
#else
                int64_t __fts_bignum;
#endif
        } __union_ftsent;
#define fts_number      __union_ftsent.__struct_ftsent.__fts_number
#define fts_pointer     __union_ftsent.__struct_ftsent.__fts_pointer
#define fts_bignum      __union_ftsent.__fts_bignum
	char *fts_accpath;		/* access path */
	char *fts_path;			/* root path */
	int fts_errno;			/* errno for this node */
	int fts_symfd;			/* fd for symlink or chdir */
	unsigned short fts_pathlen;	/* strlen(fts_path) */
	unsigned short fts_namelen;	/* strlen(fts_name) */

	ino_t fts_ino;			/* inode */
	dev_t fts_dev;			/* device */
	nlink_t fts_nlink;		/* link count */
	short fts_level;		/* depth (-1 to N) */
	unsigned short fts_info;	/* user flags for FTSENT structure */
	unsigned short fts_flags;	/* private flags for FTSENT structure */
	unsigned short fts_instr;	/* fts_set() instructions */
	struct stat *fts_statp;		/* stat(2) information */
	char fts_name[1];		/* file name */
} COMPATFTSENT;

#define	COMPAT_FTS_BIGNUM(p)	((COMPATFTSENT *)p)->fts_bignum

static SLIST_HEAD(ignhead, ignentry) ignores;
struct ignentry {
	char			*mask;
	SLIST_ENTRY(ignentry)	next;
};
*/


@main struct du : ShellCommand {
  
  /*
   FTS		*fts;
   FTSENT		*p;
   off_t		savednumber, curblocks;
   uint64_t	threshold, threshold_sign;
   int		ftsoptions;
   char 		**save;
   static char	dot[] = ".";

   setlocale(LC_ALL, "");

   */

  struct CommandOptions {
    var Hflag = false
    var Lflag = false
    var aflag = false
    var sflag = false
    var dflag = false
    var cflag = false
    var lflag = false
    var hflag = 0
    var Aflag = false
    var nodumpflag = false
    var cblocksize = Int(DEV_BSIZE)
    var blocksize = 0
    var depth = Int(INT_MAX)
    var threshold = 0
    var threshold_sign = 1
    var ftsoptions : FTSFlags = []
    var args : [String] = []
  }

  var options : CommandOptions!

  /*
   save = argv;
   ftsoptions = FTS_PHYSICAL;
   #ifdef __APPLE__
   // rdar://4924219
   ftsoptions |= FTS_NOCHDIR;
   #endif
   savednumber = 0;
   threshold = 0;
   threshold_sign = 1;
   SLIST_INIT(&ignores);
   */

  let long_opts : [CMigration.option] = [
    option.init("si", .no_argument),
    //    { "si", no_argument, NULL, SI_OPT },
  ]


  func howmany(_ x : Int, _ y : Int) -> Int {
    ((x % y) == 0) ? (x / y) : ((x / y) + 1) /* # y's == x bits? */
  }

  func parseOptions() throws(CmdErr) -> CommandOptions {
    var options = CommandOptions()
    let go = BSDGetopt_long("+AB:HI:LPasd:cghklmnrt:x", long_opts)

    while let (k, v) = try go.getopt_long() {
      switch k {
        case "A":
          options.Aflag = true
        case "B":
          if let c = Int(v), c > 0 {
            options.cblocksize = c
          } else {
            throw CmdErr(1, "invalid argument to option B: \(v)")
          }
        case "H":
          options.Hflag = true
          options.Lflag = false
        case "I":
          ignoreadd(v);
        case "L":
          options.Lflag = true
          options.Hflag = false
        case "P":
          options.Hflag = false
          options.Lflag = false
        case "a":
          options.aflag = true
        case "s":
          options.sflag = true
        case "d":
          options.dflag = true
          errno = 0;
          if let d = Int(v), d >= 0 {
            options.depth = d
          } else {
            throw CmdErr(1, "invalid argument to option d: v")
          }
        case "c":
          options.cflag = true
        case "g":
          options.hflag = 0
          options.blocksize = 1073741824
        case "h":
          options.hflag = UNITS_2
        case "k":
          options.hflag = 0
          options.blocksize = 1024
        case "l":
          options.lflag = true
        case "m":
          options.hflag = 0
          options.blocksize = 1048576
        case "n":
          options.nodumpflag = true
        case "r":		 /* Compatibility. */
          break
        case "t" :
          if let threshold = try? expand_number(v), threshold != 0 {
            options.threshold = Int(threshold)
            options.threshold_sign = threshold < 0 ? -1 : 1
          } else {
            throw CmdErr(1, "invalid threshold: \(v)")
          }
        case "x":
          options.ftsoptions.insert(.XDEV)
        case "si":
          options.hflag = UNITS_SI
        case "?":
          fallthrough
        default:
          throw CmdErr(1)
      }
    }

    options.args = go.remaining

    if options.Hflag {
      options.ftsoptions.insert(.COMFOLLOW)
    }
    if options.Lflag {
      options.ftsoptions.remove(.PHYSICAL)
      options.ftsoptions.insert(.LOGICAL)
    }

    if !options.Aflag && (options.cblocksize % Int(DEV_BSIZE)) != 0 {
      options.cblocksize = howmany(options.cblocksize, Int(DEV_BSIZE) ) * Int(DEV_BSIZE)
    }

    if (options.aflag ? 1 : 0) + (options.dflag ? 1 : 0) + (options.sflag ? 1 : 0) > 1 {
      throw CmdErr(1)
    }
    if options.sflag {
      options.depth = 0
    }

    if options.args.isEmpty {
      options.args = ["."]
    }

    if options.blocksize == 0 {
      var notused : Int32 = 0
      Darwin.getbsize(&notused, &options.blocksize)
    }

    if !options.Aflag {
      options.cblocksize /= Int(DEV_BSIZE)
      options.blocksize /= Int(DEV_BSIZE)
    }

    if options.threshold != 0 {
      options.threshold = howmany(options.threshold / Int(DEV_BSIZE) * options.cblocksize, options.blocksize)
    }

    return options
  }

  /*
   * XXX
   * Because of the way that fts(3) works, logical walks will not count
   * the blocks actually used by symbolic links.  We rationalize this by
   * noting that users computing logical sizes are likely to do logical
   * copies, so not counting the links is correct.  The real reason is
   * that we'd have to re-implement the kernel's symbolic link traversing
   * algorithm to get this right.  If, for example, you have relative
   * symbolic links referencing other relative symbolic links, it gets
   * very nasty, very fast.  The bottom line is that it's documented in
   * the man page, so it's a feature.
   */

  func runCommand() async throws(CmdErr) {


    //    #ifdef __APPLE__
    // rdar://44903941
    // "du" should not have any side effect on disk usage,
    // so prevent materializing dataless directories upon traversal
    var rval : Int32 = 1
    Darwin.sysctlbyname("vfs.nspace.prevent_materialization", nil, nil, &rval, MemoryLayout.size(ofValue: rval))
    // #endif /* __APPLE__ */

    rval = 0;

    signal(SIGINFO, siginfo)

    var savednumber = 0

    do {
      let fts = try FTSWalker(path: options.args, options: options.ftsoptions, sort: nil)

      //    if ((fts = fts_open(argv, ftsoptions, NULL)) == NULL)  err(1, "fts_open");

      //    while ((void)(errno = 0), (p = fts_read(fts)) != NULL) {
      for var p in fts {
        switch p.info {
          case .D:			/* Ignore. */
            if ignorep(p) || dirlinkchk(p) {
              p.setAction(.SKIP)
//              fts_set(fts, p, FTS_SKIP)
            }
          case .DP:
            if ignorep(p) {
              break;
            }

            let curblocks = options.Aflag ?
            howmany(Int(p.statp!.size), options.cblocksize) :
            howmany(Int(p.statp!.blocks), options.cblocksize)
            p.number += curblocks
            p.parent?.pointee.fts_number += p.number

            if (p.level <= options.depth && options.threshold <=
                options.threshold_sign * howmany(p.number *
                                         options.cblocksize, options.blocksize)) {
              if options.hflag > 0 {
                prthumanval(p.number)
                print("\t\(p.path)")
              } else {
                let jd = howmany(p.number * options.cblocksize, options.blocksize)
                print("\(jd)\t\(p.path)")
              }
            }
            if info != 0 {
              info = 0;
              print("\t\(p.path)")
            }
          case .DC:			/* Ignore. */
            if unix2003 {
              // FIXME: need the cyle path
              errx(1, "Can't follow symlink cycle from \(p.path)")
//               errx(1, "Can't follow symlink cycle from \(p.path) to %s", p->fts_cycle->fts_path);
            }
          case .DNR, .ERR, .NS:			/* Warn, continue. */
            warnx("\(p.path): \(p.errno.localizedDescription)")
            rval = 1
          case .SLNONE:
            if unix2003 {
              var sb = stat()
              let rc = stat(p.path, &sb)
              if (rc < 0 && errno == ELOOP) {
                errx(1, "Too many symlinks at \(p.path)")
              }
            }
            fallthrough
          default:
            if ignorep(p) {
              break
            }

            if !options.lflag && p.statp!.links > 1 && linkchk(p) {
              break
            }

            let curblocks = options.Aflag ?
            howmany(Int(p.statp!.size), options.cblocksize) :
            howmany(Int(p.statp!.blocks), options.cblocksize)

            if options.aflag || p.level == 0 {
              if options.hflag > 0 {
                prthumanval(curblocks);
                print("\t\(p.path)")
              } else {
                let jd = howmany(curblocks * options.cblocksize, options.blocksize)
                print("\(jd)\t\(p.path)")
              }
            }

            p.parent?.pointee.fts_number += curblocks
        }
        savednumber = p.parent!.pointee.fts_number
      }
    } catch(let e) {
    throw CmdErr(1, "fts_read: \(e.localizedDescription)")
  }

    if options.cflag {
      if options.hflag > 0 {
        prthumanval(savednumber)
        print("\ttotal")
      } else {
        let jd = howmany(savednumber * options.cblocksize, options.blocksize)
        print("\(jd)\ttotal")

      }
    }

    ignoreclean();
//    #ifdef __APPLE__
    if (rval == 0 && (ferror(stdout) != 0 || fflush(stdout) != 0)) {
      err(1, "stdout");
    }
// #endif
    exit(rval);
  }

  func linkchk(_ p : FtsEntry) -> Bool {
/*    struct links_entry {
      struct links_entry *next;
      struct links_entry *previous;
      int	 links;
      dev_t	 dev;
      ino_t	 ino;
    };
    static const size_t links_hash_initial_size = 8192;
    static struct links_entry **buckets;
    static struct links_entry *free_list;
    static size_t number_buckets;
    static unsigned long number_entries;
//    static char stop_allocating;
    struct links_entry *le, **new_buckets;
    struct stat *st;
    size_t i, new_size;
    int hash;
*/
    let st = p.statp!

    /* If necessary, initialize the hash table. */
/*    if (buckets == NULL) {
      number_buckets = links_hash_initial_size;
      buckets = malloc(number_buckets * sizeof(buckets[0]));
      if (buckets == NULL)
          errx(1, "No memory for hardlink detection");
      for (i = 0; i < number_buckets; i++)
            buckets[i] = NULL;
    }

    /* If the hash table is getting too full, enlarge it. */
    if (number_entries > number_buckets * 10 && !stop_allocating) {
      new_size = number_buckets * 2;
      new_buckets = calloc(new_size, sizeof(struct links_entry *));

      /* Try releasing the free list to see if that helps. */
      if (new_buckets == NULL && free_list != NULL) {
        while (free_list != NULL) {
          le = free_list;
          free_list = le->next;
          free(le);
        }
        new_buckets = calloc(new_size, sizeof(new_buckets[0]));
      }

      /*
      if (new_buckets == NULL) {
        stop_allocating = 1;
        warnx("No more memory for tracking hard links");
      } else {
        for (i = 0; i < number_buckets; i++) {
          while (buckets[i] != NULL) {
            /* Remove entry from old bucket. */
            le = buckets[i];
            buckets[i] = le->next;

            /* Add entry to new bucket. */
            hash = (le->dev ^ le->ino) % new_size;

            if (new_buckets[hash] != NULL)
                new_buckets[hash]->previous =
                le;
            le->next = new_buckets[hash];
            le->previous = NULL;
            new_buckets[hash] = le;
          }
        }
        free(buckets);
        buckets = new_buckets;
        number_buckets = new_size;
      }
      */
    }
*/

    let le = links_entry(dev: st.device, ino: st.inode)
    if buckets.f.contains(le) {
      return true
    }
/*
    /* Try to locate this entry in the hash table. */
    hash = ( st->st_dev ^ st->st_ino ) % number_buckets;
    for (le = buckets[hash]; le != NULL; le = le->next) {
      if (le->dev == st->st_dev && le->ino == st->st_ino) {
        /*
         * Save memory by releasing an entry when we've seen
         * all of its links.
         */
        if (--le->links <= 0) {
          if (le->previous != NULL)
              le->previous->next = le->next;
          if (le->next != NULL)
              le->next->previous = le->previous;
          if (buckets[hash] == le)
              buckets[hash] = le->next;
          number_entries--;
          /* Recycle this node through the free list */
          if (stop_allocating) {
            free(le);
          } else {
            le->next = free_list;
            free_list = le;
          }
        }
        return (1);
      }
    }
*/

/*    if (stop_allocating)
        return (0);

    /* Add this entry to the links cache. */
    if (free_list != NULL) {
      /* Pull a node from the free list if we can. */
      le = free_list;
      free_list = le->next;
    } else
    /* Malloc one if we have to. */
      le = malloc(sizeof(struct links_entry));
    if (le == NULL) {
      stop_allocating = 1;
      warnx("No more memory for tracking hard links");
      return (0);
    }
    le->dev = st->st_dev;
    le->ino = st->st_ino;
    le->links = st->st_nlink - 1;
    number_entries++;
    le->next = buckets[hash];
    le->previous = NULL;
    if (buckets[hash] != NULL)
        buckets[hash]->previous = le;
 */
    buckets.f.insert(le)
    return false
  }

  struct links_entry : Hashable {
/*      struct links_entry *next;
    struct links_entry *previous;
    int   links;
*/
    var dev : UInt
    var ino : UInt
  }

  class Buckets {
    var f : Set<links_entry> = []
    var d : Set<links_entry> = []
  }

  var buckets = Buckets()

  func dirlinkchk(_ p : FtsEntry) -> Bool {
//    static const size_t links_hash_initial_size = 8192;
//    static struct links_entry **buckets;
//    static struct links_entry *free_list;
//    static size_t number_buckets;
//    static unsigned long number_entries;
//    static char stop_allocating;
//    struct links_entry *le, **new_buckets;
//    struct stat *st;
//    size_t i, new_size;
//    int hash;
    struct attrbuf {
      var size : Int = 0
      var linkcount : Int = 0
    }
    var buf = attrbuf()
    var attrList = Darwin.attrlist()

//    memset(&attrList, 0, sizeof(attrList));

    attrList.bitmapcount = UInt16(ATTR_BIT_MAP_COUNT)
    attrList.dirattr = UInt32(ATTR_DIR_LINKCOUNT)
    if (-1 == getattrlist(p.path, &attrList, &buf, MemoryLayout<attrbuf>.size, 0)) {
      return false
    }
    if (buf.linkcount == 1) {
      return false
    }
    let st = p.statp!

    /* If necessary, initialize the hash table. */
    /*
    if (buckets == NULL) {
      number_buckets = links_hash_initial_size;
      buckets = malloc(number_buckets * sizeof(buckets[0]));
      if (buckets == NULL)
          errx(1, "No memory for directory hardlink detection");
      for (i = 0; i < number_buckets; i++)
            buckets[i] = NULL;
    }
*/

    /* If the hash table is getting too full, enlarge it. */
/*    if (number_entries > number_buckets * 10 && !stop_allocating) {
      new_size = number_buckets * 2;
      new_buckets = calloc(new_size, sizeof(struct links_entry *));

      /* Try releasing the free list to see if that helps. */
      if (new_buckets == NULL && free_list != NULL) {
        while (free_list != NULL) {
          le = free_list;
          free_list = le->next;
          free(le);
        }
        new_buckets = calloc(new_size, sizeof(new_buckets[0]));
      }
*/

/*      if (new_buckets == NULL) {
        stop_allocating = 1;
        warnx("No more memory for tracking directory hard links");
      } else {
 */
/*        for (i = 0; i < number_buckets; i++) {
          while (buckets[i] != NULL) {
            /* Remove entry from old bucket. */
            le = buckets[i];
            buckets[i] = le->next;

            /* Add entry to new bucket. */
            hash = (le->dev ^ le->ino) % new_size;

            if (new_buckets[hash] != NULL)
                new_buckets[hash]->previous =
                le;
            le->next = new_buckets[hash];
            le->previous = NULL;
            new_buckets[hash] = le;
          }
        }
        free(buckets);
        buckets = new_buckets;
        number_buckets = new_size;
      }
//    }
*/

    /* Try to locate this entry in the hash table. */
    let le = links_entry(dev: st.device, ino: st.inode)

    if buckets.d.contains(le) {
      return true
    }
/*    hash = ( st->st_dev ^ st->st_ino ) % number_buckets;
    for (le = buckets[hash]; le != NULL; le = le->next) {
      if (le->dev == st->st_dev && le->ino == st->st_ino) {
        /*
         * Save memory by releasing an entry when we've seen
         * all of its links.
         */
        if (--le->links <= 0) {
          if (le->previous != NULL)
              le->previous->next = le->next;
          if (le->next != NULL)
              le->next->previous = le->previous;
          if (buckets[hash] == le)
              buckets[hash] = le->next;
          number_entries--;
          /* Recycle this node through the free list */
          if (stop_allocating) {
            free(le);
          } else {
            le->next = free_list;
            free_list = le;
          }
        }
        return (1);
      }
    }
 */
/*
    if (stop_allocating) {
      return (0);
    }
*/
    /* Add this entry to the links cache. */
/*    if (free_list != NULL) {
      /* Pull a node from the free list if we can. */
      le = free_list;
      free_list = le->next;
    } else
    /* Malloc one if we have to. */
      le = malloc(sizeof(struct links_entry));
    if (le == NULL) {
      stop_allocating = 1;
      warnx("No more memory for tracking hard links");
      return (0);
    }
 */
    buckets.d.insert(le)

/*    le->links = buf.linkcount - 1;
    number_entries++;
    le->next = buckets[hash];
    le->previous = NULL;
    if (buckets[hash] != NULL)
        buckets[hash]->previous = le;
    buckets[hash] = le;
 */
    return false
  }

  func prthumanval(_ bytesx : Int) {
    var bytes = bytesx * options.cblocksize
//    char buf[5];
//    int flags;

    var flags : HumanizeFlags = [.b, .nospace, .decimal]
    if !options.Aflag {
      bytes *= Int(DEV_BSIZE)
    }
    if options.hflag == UNITS_SI {
      flags.insert(.divisor_1000)
    }

    if let buf = humanize_number(4, bytes, "", nil, flags) {
      print(buf, terminator: "")
    } else {
      print("????", terminator: "")
    }
  }

  var usage : String = """
usage: du [-Aclnx] [-H | -L | -P] [-g | -h | -k | -m] [-a | -s | -d depth] [-B blocksize] [-I mask] [-t threshold] [file ...]
"""

  func ignoreadd( _ mask : String) {
    ignore.s.append(mask)
  }

  func ignoreclean() {
    ignore.s = []
  }

  class Ignore {
    var s : [String] = []
  }
  var ignore = Ignore()

  func ignorep(_ ent : FtsEntry) -> Bool {
//    #ifdef __APPLE__
    if ent.statp?.fileType == .directory && "fd" == ent.name {
      var sfsb = statfs()
      let rc = statfs(ent.accpath, &sfsb)
      let fstn = withUnsafePointer(to: sfsb.f_fstypename) {
        $0.withMemoryRebound(to: CChar.self, capacity: Int(NAME_MAX)) {
          String(cString: $0)
        }
      }
      if rc >= 0 {
        let fstn = withUnsafePointer(to: sfsb.f_fstypename) {
          $0.withMemoryRebound(to: CChar.self, capacity: Int(NAME_MAX)) {
            String(cString: $0)
          }
        }
        if "devfs" == fstn {
          /* Don't cd into /dev/fd/N since one of those is likely to be
           the cwd as of the start of du which causes all manner of
           unpleasant surprises */
          return true
        }
      }
    }

// #endif /* __APPLE__ */
    if options.nodumpflag && ent.statp!.flags.contains(.UF_NODUMP) {
      return true
    }

    for ign in ignore.s {
      if (fnmatch(ign, ent.name, 0) != FNM_NOMATCH) {
        return true
      }
    }
    return false
  }

}

var info : sig_atomic_t = 0

func siginfo(_ sig : Int32 /* __unused */) {
  info = 1;
}

