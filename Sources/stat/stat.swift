// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-2-Clause-NetBSD
 *
 * Copyright (c) 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andrew Brown.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

import CMigration
import Darwin

@main struct stat : ShellCommand {

  /*
   #if HAVE_CONFIG_H
   #include "config.h"
   #else  /* HAVE_CONFIG_H */
   #define HAVE_STRUCT_STAT_ST_FLAGS 1
   #define HAVE_STRUCT_STAT_ST_GEN 1
   #define HAVE_STRUCT_STAT_ST_BIRTHTIME 1
   #define HAVE_STRUCT_STAT_ST_MTIMENSEC 1
   #define HAVE_STRUCT_STAT_ST_ATIM 0
   // #define HAVE_DEVNAME 1
   #endif /* HAVE_CONFIG_H */

   #if HAVE_STRUCT_STAT_ST_FLAGS
   #define DEF_F "%#Xf "
   #define RAW_F "%f "
   #define SHELL_F " st_flags=%f"
   #else /* HAVE_STRUCT_STAT_ST_FLAGS */
   #define DEF_F
   #define RAW_F
   #define SHELL_F
   #endif /* HAVE_STRUCT_STAT_ST_FLAGS */

   #if HAVE_STRUCT_STAT_ST_BIRTHTIME
   #define DEF_B "\"%SB\" "
   #define RAW_B "%B "
   #define SHELL_B "st_birthtime=%B "
   #else /* HAVE_STRUCT_STAT_ST_BIRTHTIME */
   #define DEF_B
   #define RAW_B
   #define SHELL_B
   #endif /* HAVE_STRUCT_STAT_ST_BIRTHTIME */

   #if HAVE_STRUCT_STAT_ST_ATIM
   #define st_atimespec st_atim
   #define st_ctimespec st_ctim
   #define st_mtimespec st_mtim
   #endif /* HAVE_STRUCT_STAT_ST_ATIM */
*/
   let DEF_FORMAT = "%d %i %Sp %l %Su %Sg %r %z \"%Sa\" \"%Sm\" \"%Sc\" \"%SB\" %k %b %#Xf %N"
   let RAW_FORMAT	= "%d %i %#p %l %u %g %r %z %a %m %c %B %k %b %f %N"
   let LS_FORMAT = "%Sp %l %Su %Sg %Z %Sm %N%SY"
   let LSF_FORMAT	= "%Sp %l %Su %Sg %Z %Sm %N%T%SY"

   let SHELL_FORMAT = "st_dev=%d st_ino=%i st_mode=%#p st_nlink=%l st_uid=%u st_gid=%g st_rdev=%r st_size=%z st_atime=%a st_mtime=%m st_ctime=%c st_birthtime=%B st_blksize=%k st_blocks=%b st_flags=%f"
  let LINUX_FORMAT = "  File: \"%N\"%n  Size: %-11z  FileType: %HT%n  Mode: (%0Mp%03OA/%.10Sp)         Uid: (%5u/%8Su)  Gid: (%5g/%8Sg)%nDevice: %Hd,%Ld   Inode: %i    Links: %l%nAccess: %Sa%nModify: %Sm%nChange: %Sc%n Birth: %SB"

  struct FlagFlags : OptionSet {
    var rawValue : Int

    static var POUND = Self(rawValue: 0x01)
    static var SPACE = Self(rawValue: 0x02)
    static var PLUS = Self(rawValue: 0x04)
    static var ZERO = Self(rawValue: 0x08)
    static var MINUS = Self(rawValue: 0x10)
  }

   /*
    * These format characters must all be unique, except the magic one.
    */
  let FMT_MAGIC : Character = "%"
  enum FormatChars : Character {
    case DOT = "."
    case SIMPLE_NEWLINE	= "n"
    case SIMPLE_TAB = "t"
    case SIMPLE_PERCENT = "%"
    case SIMPLE_NUMBER = "@"

    case POUND = "#"
    case SPACE = " "
    case PLUS = "+"
    case ZERO = "0"
    case MINUS	= "-"

    case DECIMAL = "D"
    case OCTAL = "O"
    case UNSIGNED = "U"
    case HEX = "X"
    case FLOAT = "F"
    case STRING = "S"

    case HIGH_PIECE = "H"
    case MIDDLE_PIECE = "M"
    case LOW_PIECE = "L"
  }

  enum Piece {
    case unspecified
    case high
    case middle
    case low
  }

  struct FormatFlags : OptionSet {
    var rawValue : Int

    static var DECIMAL = Self(rawValue: 0x01)
    static var OCTAL = Self(rawValue: 0x02)
    static var UNSIGNED = Self(rawValue: 0x04)
    static var HEX = Self(rawValue: 0x08)
    static var FLOAT = Self(rawValue: 0x10)
    static var STRING = Self(rawValue: 0x20)
  }

  enum WhatToShow : Character {
    case realpath = "R"
    case st_dev = "d"
    case st_ino = "i"
    case st_mode	= "p"

    case st_mode2 = "A"

    case st_nlink = "l"
    case st_uid = "u"
    case st_gid = "g"
    case st_rdev = "r"
    case st_atime = "a"
    case st_mtime = "m"
    case st_ctime = "c"
    case st_btime = "B"
    case st_size = "z"
    case st_blocks	= "b"
    case st_blksize = "k"
    case st_flags = "f"
    case st_gen = "v"
    case symlink = "Y"
    case filetype = "T"
    case filename = "N"
    case sizerdev = "Z"
  }

  // static const char *timefmt;
  // static int linkfail;

  func addchar(_ c : Character, _ nl : inout Bool) {
    print(c, terminator: "")
    nl = c == "\n"
  }

  /*
   int
   main(int argc, char *argv[])
   {
   struct stat st;
   int ch, rc, errs, am_readlink;
   #ifdef __APPLE__
   int lsF, fmtchar, usestat, fn, nonl, quiet;
   #else
   int lsF, fmtchar, usestat, nfs_handle, fn, nonl, quiet;
   #endif
   const char *statfmt, *options, *synopsis;
   #ifndef __APPLE__
   char dname[sizeof _PATH_DEV + SPECNAMELEN] = _PATH_DEV;
   fhandle_t fhnd;
   #endif
   const char *file;

   am_readlink = 0;
   lsF = 0;
   fmtchar = '\0';
   usestat = 0;
   #ifndef __APPLE__
   nfs_handle = 0;
   #endif
   nonl = 0;
   quiet = 0;
   linkfail = 0;
   statfmt = NULL;
   timefmt = NULL;
   */

  /*
   if (strcmp(getprogname(), "readlink") == 0) {
   am_readlink = 1;
   options = "fn";
   synopsis = "[-fn] [file ...]";
   statfmt = "%Y";
   fmtchar = 'f';
   quiet = 1;
   } else {
   */

  struct CommandOptions {
    var lsF = false
    var usestat = false
    var nonl = false
    var quiet = false
    var timefmt : String? = nil
    var statfmt : String? = nil
    var fmtchar : Character? = nil
    var args = [String]()
  }

  var usage = """
usage: stat [-FLnq] [-f format | -l | -r | -s | -x] [-t timefmt] [file ...]
"""

  var options : CommandOptions!

  func parseOptions() throws(CmdErr) -> CommandOptions {
    var options = CommandOptions()
    let go = BSDGetopt("f:FlLnqrst:x")


    while let (k, v) = try go.getopt() {
      switch k {
        case "F":
          options.lsF = true
        case "L":
          options.usestat = true
        case "n":
          options.nonl = true
        case "q":
          options.quiet = true
        case "f":
          // FIXME: for readlink
          /*
          if (am_readlink) {
            statfmt = "%R";
            break;
          }
           */
          options.statfmt = v
          fallthrough
        case "l", "r", "s", "x":
          if let f = options.fmtchar {
            errx(1, "can't use format '\(f)' with '\(k)'")
          }
          options.fmtchar = k
        case "t":
          options.timefmt = v
        default:
          throw CmdErr(1)
      }
    }

    options.args = go.remaining


    if options.fmtchar == nil {
      if options.lsF {
        options.fmtchar = "l"
      }
      else {
        options.fmtchar = "f"
        options.statfmt = DEF_FORMAT
      }
    }

    if (options.lsF && options.fmtchar != "l") {
      errx(1, "can't use format '\(options.fmtchar ?? "?")' with -F")
    }

    switch options.fmtchar {
      case "f":
        /* statfmt already set */
        break
      case "l":
      options.statfmt = options.lsF ? LSF_FORMAT : LS_FORMAT;
      case "r":
      options.statfmt = RAW_FORMAT
      case "s":
      options.statfmt = SHELL_FORMAT
      case "x":
      options.statfmt = LINUX_FORMAT;
      if options.timefmt == nil {
        options.timefmt = "%c"
      }
      default:
        throw CmdErr(1)
    }

    if options.timefmt == nil {
      options.timefmt = "%b %e %T %Y"
    }

    return options
  }


  func runCommand() throws(CmdErr) {
    var errs : Int32 = 0
    var fn = 1
    if options.args.isEmpty {
        /*#ifndef __APPLE__
         if (fdevname_r(STDIN_FILENO, dname +
         sizeof _PATH_DEV - 1, SPECNAMELEN) != NULL)
         file = dname;
         else
         #endif
         */
        let file = "(stdin)"
      do {
        let st = try FileMetadata(for: FileDescriptor.standardInput)
        output(st, nil, options.statfmt ?? "", fn, options.nonl)
      } catch(let e) {
        errs = 1
//        linkfail = 1
        if (!options.quiet) {
          warn("\(file): stat")
        }
      }
    } else {
      for file in options.args {
        /*#ifndef __APPLE__
         int j;
         #endif
         */
        /*#ifndef __APPLE__
         if (nfs_handle) {
         rc = 0;
         bzero(&fhnd, sizeof(fhnd));
         j = MIN(2 * sizeof(fhnd), strlen(file));
         if ((j & 1) != 0) {
         rc = -1;
         } else {
         while (j) {
         rc = hex2byte(&file[j - 2]);
         if (rc == -1)
         break;
         ((char*) &fhnd)[j / 2 - 1] = rc;
         j -= 2;
         }
         }
         if (rc == -1)
         errno = EINVAL;
         else
         rc = fhstat(&fhnd, &st);

         } else if (usestat) {
         #else /* __APPLE__ */
         */
        var st : FileMetadata?

        do {

          if options.usestat {
            // #endif /* !__APPLE__ */
            /*
             * Try stat() and if it fails, fall back to
             * lstat() just in case we're examining a
             * broken symlink.
             */
            do {
              let stx = try FileMetadata(for: file)
              st = stx
            } catch(let e) {
              if e.code == ENOENT {
                let stx = try FileMetadata(for: file, followSymlinks: false)
                st = stx
              }
            }
          }
          else {
            try st = FileMetadata(for: file, followSymlinks: false)
          }
          if let st {
            output(st, file, options.statfmt ?? "", fn, options.nonl)
          } else {
            warn("\(file): stat")
          }
        }
        catch(let e) {
         errs = 1
//          linkfail = 1;
         if !options.quiet {
           warn("\(file): stat")
         }
        }
        fn += 1
      }
    }

    exit(errs) // (am_readlink ? linkfail : errs);
  }

// #if HAVE_STRUCT_STAT_ST_FLAGS
  /*
   * fflagstostr() wrapper that leaks only once
   */
  func xfflagstostr(_ fflags : FileFlags) -> String {
    let str = CMigration.fflagstostr(fflags)
    if (str == nil) {
      err(1, "fflagstostr")
    }
    return str!
  }
// #endif /* HAVE_STRUCT_STAT_ST_FLAGS */


  /// Parses a format string.
  func output(_ st : FileMetadata, _ file : String?, _ statfmtx : String, _ fn : Int, _ nonl : Bool) {
    //	int flags, size, prec, ofmt, hilo, what;
    //	char buf[PATH_MAX + 4 + 1];
    //	const char *subfmt;
    //	int nl, t, i;

    var nl = true
    var statfmt = statfmtx
    var ofmt = FormatFlags()
    var hilo = Piece.middle

    while !statfmt.isEmpty {
      let bb = statfmt
      let sfc = statfmt.removeFirst()

      // Non-format characters go straight out.
      if sfc != FMT_MAGIC {
        addchar(sfc, &nl)
        continue
      }

      /*
       * The current format "substring" starts here,
       * and then we skip the magic.
       */
      var subfmt = statfmt.removeFirst()

      /*
       * Some simple one-character "formats".
       */

      switch FormatChars(rawValue: subfmt) {
        case .SIMPLE_NEWLINE:
          addchar("\n", &nl)
          continue
        case .SIMPLE_TAB:
          addchar("\t", &nl)
          continue
        case .SIMPLE_PERCENT:
          addchar("%", &nl)
          continue
        case .SIMPLE_NUMBER:
          print("\(fn)", terminator: "")
          nl = false
          continue
        default:
          break
      }

      /*
       * This must be an actual format string.  Format strings are
       * similar to printf(3) formats up to a point, and are of
       * the form:
       *
       *	%	required start of format
       *	[-# +0]	opt. format characters
       *	size	opt. field width
       *	.	opt. decimal separator, followed by
       *	prec	opt. precision
       *	fmt	opt. output specifier (string, numeric, etc.)
       *	sub	opt. sub field specifier (high, middle, low)
       *	datum	required field specifier (size, mode, etc)
       *
       * Only the % and the datum selector are required.  All data
       * have reasonable default output forms.  The "sub" specifier
       * only applies to certain data (mode, dev, rdev, filetype).
       * The symlink output defaults to STRING, yet will only emit
       * the leading " -> " if STRING is explicitly specified.  The
       * sizerdev datum will generate rdev output for character or
       * block devices, and size output for all others.
       */
      var flags : FlagFlags = []
      loop: while !statfmt.isEmpty {
        switch FormatChars(rawValue: subfmt) {
          case .POUND:
          flags.insert(.POUND)
          case .SPACE:
          flags.insert(.SPACE)
          case .PLUS:
          flags.insert(.PLUS)
          case .ZERO:
          flags.insert(.ZERO)
          case .MINUS:
          flags.insert(.MINUS)
          default:
          break loop
        }
        subfmt = statfmt.removeFirst()
      }

      var size = -1
      if true == subfmt.isWholeNumber {
        let p = statfmt.prefix { $0.isWholeNumber }
        let size = Int(String(subfmt)+p)!
        statfmt.removeFirst(p.count)
        subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
      }

      var prec = -1
      if FormatChars(rawValue: subfmt) == .DOT {
        let p = statfmt.prefix { $0.isWholeNumber }
        let prec = Int(p) ?? -1
        statfmt.removeFirst(p.count)
        subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
      }

      switch FormatChars(rawValue: subfmt) {
        case .DECIMAL:
          ofmt = .DECIMAL
          subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
        case .OCTAL:
          ofmt = .OCTAL
          subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
        case .UNSIGNED:
          ofmt = .UNSIGNED
          subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
        case .HEX:
          ofmt = .HEX
          subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
        case .FLOAT:
          ofmt = .FLOAT
          subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
        case .STRING:
          ofmt = .STRING
          subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
        default:
          ofmt = []
      }

      switch FormatChars(rawValue: subfmt) {
        case .HIGH_PIECE:
          hilo = .high
          subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
        case .MIDDLE_PIECE:
          hilo = .middle
          subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
        case .LOW_PIECE:
          hilo = .low
          subfmt = statfmt.isEmpty ? "\0" : statfmt.removeFirst()
        default:
          hilo = .unspecified
      }

      let j = bb.count - statfmt.count + 1
      let tf = String(bb.prefix(j))

      guard let what = WhatToShow(rawValue: subfmt) else {
        // FIXME: take a substring of statfmt up to the point where the error is occuring
        errx(1, "\(tf): bad format")
        // FIXME: exit more cleanly?
        fatalError()
      }

      let buf = format1(st, file, tf, flags, size, prec, ofmt, hilo, what)

      print(buf, terminator: "")
      nl = false
    }

    if (!nl && !nonl) {
      print("")
    }
  }

  /*
   * Arranges output according to a single parsed 1 substring.
   */
  func format1(_ st : FileMetadata, _ file : String?, _ fmt : String,
  _ flags : FlagFlags, _ sizex : Int, _ precx : Int, _ ofmtx : FormatFlags,
  _ hilox : Piece, _ what : WhatToShow) -> String
  {
    var ofmt = ofmtx
    var hilo = hilox
    var prec = precx
    var size = sizex

/*    u_int64_t data;
    char *stmp, lfmt[24], tmp[20];
 */

    var data : UInt = 0
    var sdata : String? = nil
    /*
    char smode[12], sid[12], path[PATH_MAX + 4];
    const struct timespec *tsp;
    struct timespec ts = {0,0};
    struct tm *tm;
    int l, small, formats;
*/

    var tsp : DateTime? = nil

    // #ifndef __APPLE__
    var formats = FormatFlags()
    // 	small = 0;
    // #endif

    /*
     * First, pick out the data and tweak it based on hilo or
     * specified output format (symlink output only).
     */
    switch what {
      case .st_dev, .st_rdev:
//        let small = (sizeof(st->st_dev) == 4);
        data = (what == .st_dev) ? st.device : st.rawDevice

        var ssdata = (what == .st_dev) ?
        Darwin.devname(Int32(st.device), S_IFBLK) :
        Darwin.devname(Int32(st.rawDevice),
                       st.fileType == .characterDevice ? S_IFCHR :
                        st.fileType == .blockDevice ? S_IFBLK :
                  0)
        sdata = ssdata == nil ? "???" : String(cString: ssdata!)

        if (hilo == .high) {
          data = (data >> 24) & 0x0ff
          hilo = .unspecified
        }
        else if (hilo == .low) {
          data = data & 0x0ffffff
          hilo = .unspecified
        }
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX, .STRING]
        if (ofmt == []) {
          ofmt = .UNSIGNED
        }
      case .st_ino:
//        small = (sizeof(st->st_ino) == 4);
        let data = st.inode
        sdata = nil
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX]
        if (ofmt == []) {
          ofmt = .UNSIGNED
        }
      case .st_mode, .st_mode2:
//        small = (sizeof(st->st_mode) == 4);
        // FIXME: mode needs to be reconstructed from fileType and mode?
        data = UInt(st.mode.rawValue) // | (UInt(st.fileType.rawValue) << 16)
        var stmp = CMigration.strmode(st.fileType, st.mode)
        if stmp.last == " " { stmp.removeLast() }

        // #ifdef __APPLE__
        if (what == .st_mode2) {
          data &= 07777
        }
        // #endif
        if hilo == .high {
          data >>= 12
          stmp = String(stmp.dropFirst().prefix(3))
          hilo = .unspecified
        }
        else if hilo == .middle {
          data = (data >> 9) & 07;
          stmp = String(stmp.dropFirst(4).prefix(3))
          hilo = .unspecified
        }
        else if (hilo == .low) {
          data &= 0777
          stmp = String(stmp.dropFirst(7).prefix(3))
          hilo = .unspecified
        }
        sdata = stmp
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX, .STRING]
        if (ofmt == []) {
          ofmt = .OCTAL
        }
      case .st_nlink:
//        small = (sizeof(st->st_dev) == 4);
        data = st.links
        sdata = nil
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX]
        if (ofmt == []) {
          ofmt = .UNSIGNED
        }
        break;
      case .st_uid:
//        small = (sizeof(st->st_uid) == 4);
        data = st.userId
        if let k = user_from_uid(UInt32(st.userId), 1) {
          sdata = String(cString: k)
        } else {
          sdata = "(\(st.userId))"
        }
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX, .STRING]
        if ofmt == [] {
          ofmt = .UNSIGNED
        }
      case .st_gid:
//        small = (sizeof(st->st_gid) == 4);
        data = st.groupId
        if let k = group_from_gid(UInt32(st.groupId), 1) {
          sdata = String(cString: k)
        } else {
          sdata = "(\(st.groupId))"
        }
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX, .STRING]
        if (ofmt == []) {
          ofmt = .UNSIGNED
        }
      case .st_atime:
        tsp = st.lastAccess
        fallthrough
      case .st_mtime:
        if (tsp == nil) {
          tsp = st.lastWrite
        }
        fallthrough
      case .st_ctime:
        if (tsp == nil) {
          tsp = st.lastModification
        }
        fallthrough
// #if HAVE_STRUCT_STAT_ST_BIRTHTIME
      case .st_btime:
        if (tsp == nil) {
          tsp = st.created
        }
// #endif /* HAVE_STRUCT_STAT_ST_BIRTHTIME */
//        small = (sizeof(ts.tv_sec) == 4);
        data = UInt(tsp!.secs)
        var tm = localtime(&tsp!.secs)
        if (tm == nil) {
          tsp!.secs = 0
          tm = localtime(&tsp!.secs)
        }

        {
          var path = Array(repeating: CChar(0), count: 1024)
          strftime(&path, 1024, options.timefmt, tm)
          sdata = String(cString: path)
        }()

        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX, .FLOAT, .STRING]
        if (ofmt == []) {
          ofmt = .DECIMAL
        }
      case .st_size:
//        small = (sizeof(st->st_size) == 4);
        data = st.size
        sdata = nil
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX]
        if (ofmt == []) {
          ofmt = .UNSIGNED
        }
      case .st_blocks:
  //      small = (sizeof(st->st_blocks) == 4);
        data = st.blocks
        sdata = nil
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX]
        if (ofmt == []) {
          ofmt = .UNSIGNED
        }
      case .st_blksize:
//        small = (sizeof(st->st_blksize) == 4);
        data = st.blockSize
        sdata = nil
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX]
        if (ofmt == []) {
          ofmt = .UNSIGNED
        }
// #if HAVE_STRUCT_STAT_ST_FLAGS
      case .st_flags:
//        small = (sizeof(st->st_flags) == 4);
        data = UInt(st.flags.rawValue)
        sdata = xfflagstostr(st.flags)
        if sdata == nil || sdata!.isEmpty  {
          sdata = "-"
        }
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX, .STRING]
        if (ofmt == []) {
          ofmt = .UNSIGNED
        }
// #endif /* HAVE_STRUCT_STAT_ST_FLAGS */
// #if HAVE_STRUCT_STAT_ST_GEN
      case .st_gen:
//        small = (sizeof(st->st_gen) == 4);
        data = st.generation
        sdata = nil
        formats = [.DECIMAL, .OCTAL, .UNSIGNED, .HEX]
        if ofmt == [] {
          ofmt = .UNSIGNED
        }
// #endif /* HAVE_STRUCT_STAT_ST_GEN */
      case .realpath:
//        small = 0;
        data = 0;
        if file == nil {
          sdata = "(stdin)"
        } else {
          if let p = Darwin.realpath(file, nil) {
            sdata = (ofmt == .STRING ? " -> " : "") + String(cString: p)
            free(p)
//          } else {
//            linkfail = 1;
          }
        }

        formats = [.STRING]
        if (ofmt == []) {
          ofmt = .STRING
        }
      case .symlink:
//        small = 0;
        data = 0;
        if st.fileType == .symbolicLink {
          var path = Array(repeating: CChar(0), count: Int(PATH_MAX))
          let l = readlink(file, &path, Int(PATH_MAX)-1)
          let p = String(cString: path)
//          if (l == -1) {
//            linkfail = 1;
//            l = 0;
//            path[0] = '\0';
          sdata = (ofmt == .STRING ? " -> " : "") + p
        }
        else {
//          linkfail = 1;
          sdata = "";
        }
        formats = [.STRING]
        if (ofmt == []) {
          ofmt = .STRING
        }
      case .filetype:
//        small = 0;
        data = 0;
        sdata = "";
        if (hilo == .unspecified || hilo == .low) {
          switch st.fileType {
            case .fifo:	sdata = "|"
            case .directory:	sdata = "/"
            case .regular:
              if st.mode.contains([.ownerExecute, .groupExecute, .otherExecute]) {
                sdata = "*"
              }
            case .symbolicLink:	sdata = "@"
            case .socket:	sdata = "="
            case .whiteOut:	sdata = "%"
//               #ifdef S_IFDOOR
//            case S_IFDOOR:	sdata = ">";	break;
// #endif /* S_IFDOOR */
            default: break
          }
          hilo = .unspecified
        }
        else if (hilo == .high) {
          switch st.fileType {
            case .fifo:	sdata = "Fifo File"
            case .characterDevice:	sdata = "Character Device"
            case .directory:	sdata = "Directory"
            case .blockDevice: sdata = "Block Device"
            case .regular:	sdata = "Regular File"
            case .symbolicLink: sdata = "Symbolic Link"
            case .socket:	sdata = "Socket"
            case .whiteOut: sdata = "Whiteout File"
//               #ifdef S_IFDOOR
//            case S_IFDOOR:	sdata = "Door";			break;
// #endif /* S_IFDOOR */
            default:	sdata = "???";			break;
          }
          hilo = .unspecified
        }
        formats = [.STRING]
        if (ofmt == []) {
          ofmt = .STRING
        }
      case .filename:
//        small = 0;
        data = 0;
        sdata = file
        formats = [.STRING]
        if (ofmt == []) {
          ofmt = .STRING
        }
      case .sizerdev:
        if st.fileType == .characterDevice || st.fileType == .blockDevice {
          let majdev = format1(st, file, fmt, flags, size, prec, ofmt, .high, .st_rdev)
          let mindev = format1(st, file, fmt, flags, size, prec, ofmt, .low, .st_rdev)
          return "\(majdev),\(mindev)"
        }
        else {
          return format1(st, file, fmt, flags, size, prec, ofmt, .unspecified, .st_size)
        }
//      default:
//        errx(1, "\(fmt): bad format")
    }

    /*
     * If a subdatum was specified but not supported, or an output
     * format was selected that is not supported, that's an error.
     */
    if hilo != .unspecified || ofmt.isDisjoint(with: formats) {
      errx(1, "\(fmt): bad format")
    }

    /*
     * Assemble the format string for passing to printf(3).
     */
    var lfmt = "%"
    if flags.contains(.POUND) {
      lfmt.append("#")
    }
    if flags.contains(.SPACE) {
      lfmt.append(" ")
    }
    if flags.contains(.PLUS) {
      lfmt.append("+")
    }
    if flags.contains(.MINUS) {
      lfmt.append("-")
    }
    if flags.contains(.ZERO) {
      lfmt.append("0")
    }

    /*
     * Only the timespecs support the FLOAT output format, and that
     * requires work that differs from the other formats.
     */
    if (ofmt == .FLOAT) {
      /*
       * Nothing after the decimal point, so just print seconds.
       */
      if (prec == 0) {
        if (size != -1) {
          lfmt.append("\(size)")
        }
        lfmt.append("lld")
        let s = String(cString: fmtcheck(lfmt, "%lld"))
        return cFormat(s, tsp!.secs)
      }

      /*
       * Unspecified precision gets all the precision we have:
       * 9 digits.
       */
      if (prec == -1) {
        prec = 9
      }

      /*
       * Adjust the size for the decimal point and the digits
       * that will follow.
       */
      size -= prec + 1

      /*
       * Any leftover size that's legitimate will be used.
       */
      if (size > 0) {
        lfmt.append("\(size)")
      }
      /* Seconds: time_t cast to long long. */
      lfmt.append("lld")

      /*
       * The stuff after the decimal point always needs zero
       * filling.
       */
      lfmt.append(".%0")

      /*
       * We can "print" at most nine digits of precision.  The
       * rest we will pad on at the end.
       *
       * Nanoseconds: long.
       */
      lfmt.append("\(min(prec, 9))ld")

      /*
       * For precision of less that nine digits, trim off the
       * less significant figures.
       */
      while prec < 9 {
        tsp!.secs /= 10
        prec += 1
      }

      /*
       * Use the format, and then tack on any zeroes that
       * might be required to make up the requested precision.
       */
      let s = String(cString: fmtcheck(lfmt, "%lld %ld"))
      var r = cFormat(s, Int64(tsp!.secs), Int32(tsp!.nanosecs))
      if prec > 9 { r.append(contentsOf: String(repeating: "0", count: prec-9))
        prec = 9
      }
      return r
    }

    /*
     * Add on size and precision, if specified, to the format.
     */
    if (size != -1) {
      lfmt.append("\(size)")
    }
    if (prec != -1) {
      lfmt.append(".\(prec)")
    }

    /*
     * String output uses the temporary sdata.
     */
    if (ofmt == .STRING) {
      if (sdata == nil) {
        errx(1, "\(fmt): bad format")
      }
      lfmt.append("s")
      let s = String(cString: fmtcheck(lfmt, "%s"))
      return cFormat(s, sdata!)
    }

    /*
     * Ensure that sign extension does not cause bad looking output
     * for some forms.
     */
    // FIXME: do I need this?
/*    if (small && ofmt != .DECIMAL)
        data = (u_int32_t)data;
*/

    /*
     * The four "numeric" output forms.
     */
    lfmt.append("ll")
    switch ofmt {
      case .DECIMAL:	lfmt.append("d")
      case .OCTAL:		lfmt.append("o")
      case .UNSIGNED:	lfmt.append("u")
      case .HEX:      lfmt.append("x")
      default:
        break
    }

    let s = String(cString: fmtcheck(lfmt, "%llu"))
    return cFormat(s, data)
  }


  func hex2nibble(_ c : Character) -> Int {
    Array("0123456789ABCDEF").firstIndex(of: c) ?? 16
  }

  func hex2byte(_ c : (Character, Character) ) -> UInt8 {
    if c.0.isHexDigit && c.1.isHexDigit {
      return UInt8((hex2nibble(c.0) << 4) + hex2nibble(c.1))
    } else {
      return 0xff
    }
  }
}
