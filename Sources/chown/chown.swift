// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Darwin

/*static uid_t uid;
static gid_t gid;
static int ischown;
#ifdef __APPLE__
static int isnumeric = 0;
#endif
static const char *gname;
 */

var siginfo : sig_atomic_t = 0

func siginfo_handler(_ sig : Int32) {
	siginfo = 1;
}


let unix2003_compat = true  // COMPAT_MODE("bin/chown", "Unix2003");

@main struct chown : ShellCommand {
  //	FTS *ftsp;
  //	FTSENT *p;
  //	int ch, fts_options, rval;
  //	char *cp;


  //  ischown = (strcmp(basename(argv[0]), "chown") == 0);

  struct CommandOptions {
    var Hflag = false
    var Lflag = false
    var Pflag = false
    var Rflag = false
    var fflag = false
    var hflag = false
    var vflag = 0
    var xflag = false
    var isnumeric = false
    var fts : FTSFlags = []
    var uid : uid_t?
    var gid : gid_t?
    var gname : String = ""
    var args : [String] = []
  }

  var options : CommandOptions!

  func parseOptions() throws(CmdErr) -> CommandOptions {
    var options = CommandOptions()

    var go = BSDGetopt("HLPRfhnvx")
    // #ifdef __APPLE__
    while let (k, _) = try go.getopt() {
      switch k {
        case "H":
          options.Hflag = true
          options.Lflag = false
          options.Pflag = false
        case "L":
          options.Lflag = true
          options.Hflag = false
          options.Pflag = false
        case "P":
          options.Pflag = true
          options.Hflag = false
          options.Lflag = false
        case "R":
          options.Rflag = true
        case "f":
          options.fflag = true
        case "h":
          options.hflag = true
        case "n":
          options.isnumeric = true
        case "v":
          options.vflag += 1
        case "x":
          options.xflag = true
        case "?":
          fallthrough
        default:
          throw CmdErr(1)
      }
    }
    options.args = go.remaining

    if (options.args.count < 2) {
      throw CmdErr(1)
    }
    if (!options.Rflag && (options.Hflag || options.Lflag || options.Pflag)) {
      warnx("options -H, -L, -P only useful with -R")
    }

    let k = options.args.removeFirst()
    let j = k.split(separator: ":", maxSplits: 1)
    if j.count == 1 {
      options.uid = a_uid(String(j[0]), options.isnumeric)
    } else {
      options.gname = String(j[0])
      options.gid = a_gid(options.gname, options.isnumeric)
      options.uid = a_uid(String(j[1]), options.isnumeric)
    }

    signal(SIGINFO, siginfo_handler)

    if options.Rflag {
      if (options.hflag && (options.Hflag || options.Lflag)) {
        errx(1, "the -R\(options.Hflag ? "H" : "L") and -h options may not be specified together")
      }
      if options.Lflag {
        options.fts = .LOGICAL
      } else {
        options.fts = .PHYSICAL

        if (options.Hflag) {
          options.fts.insert(.COMFOLLOW)
        }
      }
    } else if (options.hflag) {
      options.fts = .PHYSICAL
    } else {
      options.fts = .LOGICAL
    }

    if (options.xflag) {
      options.fts.insert(.XDEV)
    }

    return options
  }


  func runCommand() async throws(CmdErr) {
    var rval : Int32 = 0

    do {
      let ftsp = try FTSWalker(path: options.args, options: options.fts, sort: nil)

    for var p in ftsp {

      var atflag : Int32 = 0

      if options.fts.contains(.LOGICAL) ||
          (options.fts.contains(.COMFOLLOW) && p.level == FTS_ROOTLEVEL) {
        atflag = 0
      }
      else {
        atflag = AT_SYMLINK_NOFOLLOW;
      }

      switch p.info {
        case .D:			/* Change it at FTS_DP. */
          if !options.Rflag {
            p.setAction(.SKIP)
          }
          continue
        case .DNR:			/* Warn, chown. */
          warnx("\(p.path): \(p.errno.localizedDescription)")
          rval = 1
        case .ERR, .NS:			/* Warn, continue. */
          warnx("\(p.path): \(p.errno.localizedDescription)")
          rval = 1
          continue
          // #ifdef __APPLE__
        case .SL, .SLNONE:
          /*
           * The only symlinks that end up here are ones that
           * don't point to anything and ones that we found
           * doing a physical walk.
           */
          atflag = AT_SYMLINK_NOFOLLOW
          if (unix2003_compat) {
            if (options.Hflag || options.Lflag) {       /* -H or -L was specified */
              if p.errno.code != 0 {
                warnx("\(p.name!): \(p.errno.localizedDescription)")
                rval = 1
                continue
              }
            }
          }

          // #endif
        default:
          break;
      }
      if (siginfo != 0) {
        print_info(p, 2);
        siginfo = 0
      }
      if (unix2003_compat) {
        /* Can only avoid updating times if both uid and gid are -1 */
        if ((options.uid == nil) && (options.gid == nil)) {
          continue
        }
      } else {
        if ((options.uid == nil || options.uid! == p.statp!.userId) &&
            (options.gid == nil || options.gid! == p.statp!.groupId)) {
          continue
        }
      }
      if (fchownat(AT_FDCWD, p.accpath, options.uid!, options.gid!, atflag)
          == -1 && !options.fflag) {
        chownerr(p.path)
        rval = 1
      } else if options.vflag != 0 {
        print_info(p, options.vflag)
      }
    }
    } catch(let e) {
      err(1, e.localizedDescription)
    }

    exit(rval)
  }

  func a_gid(_ s : String, _ isn : Bool) -> gid_t? {
    if s.isEmpty { return nil }   /* Argument was "uid[:.]". */

    // #ifdef __APPLE__
    if !isn {
      if let gr = getgrnam(s) {
        return gr.pointee.gr_gid
      }
    }

    return id(s, "group")
    // #else
    // 	gid = ((gr = getgrnam(s)) != NULL) ? gr->gr_gid : id(s, "group");
    // #endif
  }

  func a_uid(_ s : String, _ isn : Bool) -> uid_t? {
    if s.isEmpty { return nil }			/* Argument was "[:.]gid". */

    // #ifdef __APPLE__
    if !isn {
      if let pw = getpwnam(s) {
        return pw.pointee.pw_uid
      }
    }
    return id(s, "user")
  }



  func id(_ name : String, _ type : String) -> uid_t {
    let UID_MAX = 2147483647  /* max value for a uid_t (2^31-2) */
    if let val = Int(name) {
      if val <= UID_MAX {
        return uid_t(val)
      }
    }
    errx(1, "\(name): illegal \(type) name")
    // FIXME: should get out of here in a better way
    fatalError()
  }

  var euid = geteuid()
  var groups = {
    let ngroups_max = Int(sysconf(_SC_NGROUPS_MAX) + 1)
    var groups = Array(repeating: gid_t(0), count: ngroups_max)
    let ngroups = getgroups(Int32(ngroups_max), &groups)
    return groups[0..<Int(ngroups)]
  }()

  func chownerr(_ file : String) {

    /* Check for chown without being root. */
    if (errno != EPERM || (options.uid != nil && euid != 0)) {
      warn(file);
      return
    }

    /* Check group membership; kernel just returns EPERM. */
    if let gid = options.gid {
      if !groups.contains(gid) {
        warnx("you are not a member of group \(options.gname)")
        return
      }
    }
    warn(file)
  }

  var usage = """
usage: chown [-fhnvx] [-R [-H | -L | -P]] owner[:group] file ...
       chown [-fhnvx] [-R [-H | -L | -P]] :group file ...
"""

  func print_info(_ p : FtsEntry, _ vflag : Int) {
    print(p.path, terminator: "")
    if (vflag > 1) {
      print(": \(p.statp!.userId):\(p.statp!.groupId) -> \(options.uid == nil ? p.statp!.userId : UInt(options.uid!) ):\(options.gid == nil ? p.statp!.groupId : UInt(options.gid!) )",
            terminator: "")
    }
    print("");
  }
}
