// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2024 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Synchronization

import Darwin


struct ATFlags : OptionSet {
  var rawValue : Int32 = 0

  init(rawValue : Int32 = 0)  {
    self.rawValue = rawValue
  }

  static let EACCESS = ATFlags(rawValue: AT_EACCESS)
  static let SYMLINK_NOFOLLOW = ATFlags(rawValue: AT_SYMLINK_NOFOLLOW)
  static let SYMLINK_FOLLOW = ATFlags(rawValue: AT_SYMLINK_FOLLOW)
  static let REMOVEDIR = ATFlags(rawValue: AT_REMOVEDIR)
  static let REALDEV = ATFlags(rawValue: AT_REALDEV)
  static let FDONLY = ATFlags(rawValue: AT_FDONLY)
  static let SYMLINK_NOFOLLOW_ANY = ATFlags(rawValue: AT_SYMLINK_NOFOLLOW_ANY)
  static let RESOLVE_BENEATH = ATFlags(rawValue: AT_RESOLVE_BENEATH)
}


@main struct chflags : ShellCommand {



  /* No chflagsat(), provide a shim to minimize the later diff. */
  fileprivate func chflagsat(_ fd : Int, _  path : String, _ flags : UInt32, _ atflag : ATFlags) -> Int32 {

/*
     * This shim only provides proper semantics for AT_FDCWD and atflag with
     * either nothing set or only AT_SYMLINK_NOFOLLOW.  This is a fairly
     * narrow use-case, and this is likely to be sufficient going forward.
*/

//    assert(fd == AT_FDCWD);
//    assert((atflag & ~AT_SYMLINK_NOFOLLOW) == 0);

    if atflag.contains(.SYMLINK_NOFOLLOW) {
      return Darwin.lchflags(path, flags)
    }
    else {
      return Darwin.chflags(path, flags)
    }
  }

struct CommandOptions {
  var Hflag = false
  var Lflag = false
  var Rflag = false
  var fflag = false
  var hflag = false
  var vflag = 0
  var xflag = false
  var fts_options : FTSFlags = []
  var args : [String] = []
  var oct = false
  var set : UInt = 0
  var clear : UInt = 0
}

  func parseOptions() throws(CmdErr) -> CommandOptions {
    //    FTS *ftsp;
    //    FTSENT *p;
    //    u_long clear, newflags, set;
    //    long val;
    //    int ch, fts_options, oct, rval;
    //    char *flags, *ep;

    var opts = CommandOptions()
    //    while ((ch = getopt(argc, argv, "HLPRfhvx")) != -1)
    let go = BSDGetopt("HLPRfhvx")
    while let (k,_) = try go.getopt() {
      switch k {
      case "H":
        opts.Hflag = true
        opts.Lflag = false
      case "L":
        opts.Lflag = true
        opts.Hflag = false
      case "P":
        opts.Hflag = false
        opts.Lflag = false
      case "R":
        opts.Rflag = true
      case "f":
        opts.fflag = true
      case "h":
        opts.hflag = true
      case "v":
        opts.vflag+=1
      case "x":
        opts.xflag = true
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }

    opts.args = go.remaining
    if opts.args.count < 2 {
      throw CmdErr(1)
    }

    if opts.Rflag {
      if opts.hflag {
        throw CmdErr(1, "the -R and -h options may not be specified together.")
      }
      if opts.Lflag {
        opts.fts_options = .LOGICAL
      } else {
        opts.fts_options = .PHYSICAL

        if opts.Hflag {
          opts.fts_options.insert(.COMFOLLOW)
        }
      }
    } else if opts.hflag {
      opts.fts_options = .PHYSICAL
    } else {
      opts.fts_options = .LOGICAL
    }
    if opts.xflag {
      opts.fts_options.insert(.XDEV)
    }

    let flags = opts.args.removeFirst()

    if let ff = flags.first, ff >= "0" && ff <= "7" {
      if let val = Int(flags, radix: 8) {
        if val < 0 {
          throw CmdErr(1, POSIXErrno(ERANGE).description)
        }
        opts.set = UInt(val)
        opts.oct = true
      } else {
        throw CmdErr(1, "invalid flags: \(flags)")
      }
    } else {
      let k = flags.withCString { j in
        var jm : UnsafeMutablePointer<CChar>? = UnsafeMutablePointer(mutating: j)
        return Darwin.strtofflags(&jm, &opts.set, &opts.clear) }
      if k != 0 {
        throw CmdErr(1, "invalid flag: \(flags)")
      }
      opts.clear = ~opts.clear
      opts.oct = false
    }
    return opts
  }

  func runCommand(_ opts : CommandOptions) async throws(CmdErr) {

    Darwin.signal(SIGINFO, siginfo_handler)

    var ftsp : FTSWalker
    do {
      ftsp = try FTSWalker(path: opts.args, options: opts.fts_options)
    } catch let e {
      throw CmdErr(1, "\(e)")
    }

    var rval = 0
    var atflag = ATFlags()

    while var p = ftsp.next() { //}  for (rval = 0; (void)(errno = 0), (p = fts_read(ftsp)) != NULL;) {
//      int atflag;

      if (opts.fts_options.contains(.LOGICAL) ||
          (opts.fts_options.contains(.COMFOLLOW) &&
           p.level == FTS_ROOTLEVEL)) {
        atflag = []
      }
      else {
        atflag = .SYMLINK_NOFOLLOW;
      }

      var newflags : UInt = 0

      switch p.info {
        case .D:	/* Change it at FTS_DP if we're recursive. */
          if !opts.Rflag {
            p.setAction(.SKIP);
          }
          continue;
        case .DNR:			/* Warn, chflags. */
          warnx("\(p.path): \(p.errno.description)")
          rval = 1
        case .ERR, .NS:			/* Warn, continue. */
          warnx("\(p.path): \(p.errno.description)")
          rval = 1;
        default:
          break;
      }

      let oflags = UInt(p.statp!.flags.rawValue)
      if opts.oct {
        newflags = opts.set
      }
      else {
        newflags = (oflags | opts.set) & opts.clear
      }

      if (newflags == oflags) {
        continue
      }
      if (chflagsat(Int(AT_FDCWD), p.accpath, UInt32(newflags), atflag) == -1 && !opts.fflag) {
        warn(p.path);
        rval = 1;
      } else if (opts.vflag > 0 || (siginfo.withLock { $0 } ) ) {
        print(p.path, terminator: "")
        if (opts.vflag > 1 || (siginfo.withLock { $0 }) ) {
          print(": 0\(String(oflags, radix: 8)) -> 0\(String(newflags,  radix: 8))", terminator: "")
        }
        print("");
        siginfo.withLock {
          $0 = false
        }
      }
    }
    throw CmdErr(rval, "");
  }


  var usage : String = "usage: chflags [-fhvx] [-R [-H | -L | -P]] flags file ..."
}

let siginfo = Mutex(false)

func siginfo_handler(_  sig  : Int32) {
  siginfo.withLock { $0 = true }
}
