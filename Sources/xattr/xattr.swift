// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*
 * Copyright (c) 2007 - 2021 Apple Inc.
 *
 * This is the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

import CMigration
import Darwin

@main struct xattr : ShellCommand {

  struct CommandOptions {
    var attr_name : String = ""
    var attr_value : String = ""
    var cflag = false // clear all attributes
    var lflag = false // print long format
    var rflag = false // recursive
    var sflag = false // do not follow symbolic links
    var pflag = false // print attribute
    var wflag = false // write attribute
    var dflag = false // delete attribute
    var vflag = false // verbose
    var xflag = false // hexadecimal

    var nfiles = 0
    var args : [String] = []
    var main_opt : String? = nil
    var req_args = 0
  }

  typealias attribute_iterator = (Int32, String, String) -> Bool

  //  __attribute__((__format__ (__printf__, 2, 3)))
  /*  static void
   usage(int exit_code, const char *error_format, ...)
   {
   if (error_format != NULL) {
   va_list ap;
   va_start(ap, error_format);
   vprintf(error_format, ap);
   printf("\n\n");
   va_end(ap);
   }
   */
  var options : CommandOptions!

  var usage = """
usage: xattr [-l] [-r] [-s] [-v] [-x] file [file ...]
       xattr -p [-l] [-r] [-s] [-v] [-x] attr_name file [file ...]
       xattr -w [-r] [-s] [-x] attr_name attr_value file [file ...]
       xattr -d [-r] [-s] attr_name file [file ...]
       xattr -c [-r] [-s] file [file ...]

The first form lists the names of all xattrs on the given file(s).
The second form (-p) prints the value of the xattr attr_name.
The third form (-w) sets the value of the xattr attr_name to the string attr_value.
The fourth form (-d) deletes the xattr attr_name.
The fifth form (-c) deletes (clears) all xattrs.

options:
  -h: print this help
  -l: print long format (attr_name: attr_value and hex output has offsets and ascii representation)
  -r: act recursively
  -s: act on the symbolic link itself rather than what the link points to
  -v: also print filename (automatic with -r and with multiple files)
  -x: attr_value is represented as a hex string for input and output
"""

  /*
   __attribute__((__format__ (__printf__, 2, 3)))
*/

  func print_error(_ filename : String, _ error_format : String) {
    var stderr = FileDescriptor.standardError
    var access_flags : Int32 = 0
    if options.sflag {
      access_flags |= AT_SYMLINK_NOFOLLOW;
    }
    if (faccessat(AT_FDCWD, filename, F_OK, access_flags) != 0) {
      let saved_errno = errno
      if (saved_errno == ENOENT) {
        print("\(programName): No such file: \(filename)", to: &stderr)
        return
      }
    }

    print("\(programName): ", terminator: "", to: &stderr)
    print(error_format, to: &stderr)
  }

  func print_errno(_ filename : String, _ attr_name : String?, _ err : Int32) {
    if let attr_name,
       err == ENOATTR {
      print_error(filename, "\(filename): No such xattr: \(attr_name)")
    } else {
      if let se = strerror(err) {
        print_error(filename, "[Errno \(err)] \(se): '\(filename)'")
      } else {
        print_error(filename, "[Errno \(err)]: '\(filename)'")
      }
    }
  }

 func get_filename_prefix(_ filename : String) -> String {
   if options.vflag || options.rflag || options.nfiles > 1 {
      return "\(filename): "
    }
    return ""
  }

  func iterate_all_attributes(_ fd : Int32, _ filename : String, _ iterator_func : attribute_iterator ) -> Bool {
    var status = 0
    let res2 = flistxattr(fd, nil, 0, 0)
    if (res2 == -1) {
      print_errno(filename, nil, errno)
      return true
    }

    var buf = Array(repeating: Int8(0), count: res2)
    let res = flistxattr(fd, &buf, res2, 0)
    if (res == -1) {
      print_errno(filename, nil, errno)
      return true
    }

    var cur = buf
    while (cur.count > 0) {
      let attr_name = String(cString: cur)
      let attr_len = strlen(cur) + 1
      if iterator_func(fd, filename, attr_name) {
        // there was an error
        status = 1
      }
      cur = Array(buf.dropFirst(attr_len))
    }
    return status == 1
  }

  func get_printable_segment(_ segment : [UInt8]) -> String {
    var printable_segment = ""
    for i in segment {
      let j = isprint(Int32(i))
      let h = Character.from(i)
      let k = h == nil || j == 0 ? "." : String(h!)
      printable_segment.append(k)
    }
    return printable_segment
  }

  func print_one_xattr_hex(_ attr_value : [UInt8] ) {
    let incr = 16

    for i in stride(from: 0, to: attr_value.count, by: incr) {
      let segment = attr_value.dropFirst(i)[0..<min(incr, attr_value.count-i)]
      var segment_hex = ""
      for s in segment {
        let j = String(s, radix: 16)
        let jj = String(repeating: "0", count: 2 - j.count) + j + " "
        segment_hex.append(jj)
      }

      if options.lflag {
        let printable_segment = get_printable_segment(Array(segment))
        let kk = segment_hex + Array(repeating: " ", count: incr * 3 - segment_hex.count)
        print("%08lX  \(kk) |\(printable_segment)|", i);
      } else {
        print(segment_hex)
      }
    }
    if options.lflag {
      let hexString = String(attr_value.count, radix: 16)
      let paddedHex = String(repeating: "0", count: max(0, 8 - hexString.count)) + hexString
      print(paddedHex)
    }
  }

  func print_one_xattr(_ filename : String, _ attr_name : String, _ attr_value : [UInt8]) {

    let filename_with_prefix = get_filename_prefix(filename)
    if options.lflag {
      if options.xflag {
        print("\(filename_with_prefix)\(attr_name):", terminator: "")
        print_one_xattr_hex(attr_value)
      } else {
        print("\(filename_with_prefix)\(attr_name): \(attr_value)")
      }
    } else {
      if options.pflag {
        if options.xflag {
          if !filename_with_prefix.isEmpty {
            print("\(filename_with_prefix)")
          }
          print_one_xattr_hex(attr_value)
        } else {
          let av = String(cString: attr_value)
          print("\(filename_with_prefix)\(av)")
        }
      } else {
        print("\(filename_with_prefix)\(attr_name)")
      }
    }
  }

  func read_attribute(_ fd : Int32, _ filename : String, _ name : String) -> Bool {
    let res2 = fgetxattr(fd, name, nil, 0, 0, 0) // res is the lengtth of the attr in bytes
    if (res2 == -1) {
      print_errno(filename, name, errno)
      return true
    }

    var buf = Array(repeating: UInt8(0), count: res2)
    let res = fgetxattr(fd, name, &buf, res2, 0, 0);
    if (res == -1) {
      print_errno(filename, name, errno)
      return true
    }
    print_one_xattr(filename, name, buf)
    return false
  }

  func list_all_attributes(_ fd : Int32, _ filename : String) -> Bool {
    return iterate_all_attributes(fd, filename, read_attribute);
  }

  func delete_attribute(_ fd : Int32, _ filename : String, _ name : String) -> Bool {
    if (fremovexattr(fd, name, 0) == -1) {
      let saved_errno = errno;
      // Don't print ENOATTR errors when deleting recursively
      if (!options.rflag || (saved_errno != ENOATTR)) {
        print_errno(filename, name, saved_errno)
        return true
      }
    }
    return false
  }

  func clear_all_attributes(_ fd : Int32, _ filename : String) -> Bool {
    return iterate_all_attributes(fd, filename, delete_attribute);
  }

  func hex_to_ascii_value(_ hexstr : String) -> [UInt8] {

    let buf = (hexstr.filter { !$0.isWhitespace }).compactMap { UInt8(String($0), radix: 16) }

    var res = [UInt8]()
    for i in stride(from: 0, to: buf.count, by: 2) {
      if i+1 < buf.count {
        res.append( buf[i]*16 + buf[i+1] )
      } else {
        res.append( buf[i] )
      }
    }

    return res
  }

  func write_attribute(_ fd : Int32, _ filename : String, _ name : String, _ value : String) -> Bool {
 //   const char *actual_value = NULL;
//    char *buf = NULL;
//    size_t len = 0;

    let actual_value : [UInt8] = options.xflag ? hex_to_ascii_value(value) : value.utf8CString.map { UInt8(bitPattern: $0) }

    if (fsetxattr(fd, name, actual_value, actual_value.count, 0, 0) == -1) {
      print_errno(filename, nil, errno)
      return true
    }
    return false
  }

  func process_one_path(_ filename : String, _ name : String, _ value : String) -> Bool {
    var sb = stat()
    var is_link = false

    var status = 0

//    DIR *dir = NULL;

    var oflags = O_RDONLY
    if options.sflag {
      oflags |= O_SYMLINK
    }

    // First, we lstat() the path to find out if it's a symlink
    if lstat(filename, &sb) == -1 {
      print_errno(filename, nil, errno)
      return true
    }

    is_link = FileType(rawValue: sb.st_mode) == .symbolicLink //   S_ISLNK(sb.st_mode);

    // Note: this follows symlinks unless sflag = 1
    let fd = open(filename, oflags);
    if fd == -1 {
      print_errno(filename, nil, errno)
      return true
    }

    defer { close(fd) }

    if (fstat(fd,&sb) == -1) {
      print_errno(filename, nil, errno)
      return true
    }

    if options.rflag && !is_link && S_ISDIR(sb.st_mode) {
//      struct dirent *dirent = NULL;
      let dir = fdopendir(fd);
      if (dir == nil) {
        print_errno(filename, nil, errno)
        return true
      }

      defer  { closedir(dir) }
      while true {
        let dirent = readdir(dir)
        guard let dirent else { return status == 1 }
        // let dnam : String = dirent.pointee.d_name

        let dnam = withUnsafePointer(to: dirent.pointee.d_name) {
            $0.withMemoryRebound(to: CChar.self, capacity: Int(NAME_MAX)) {
                String(cString: $0)
            }
        }

        if dnam == "." || dnam == ".." {
          continue;
        }

        let dir_path = "\(filename)/\(dnam)"
        if process_one_path(dir_path, name, value) {
          status = 1
        }
      }
    }

    if options.wflag {
      return write_attribute(fd, filename, name, value);
    } else if options.dflag {
      return delete_attribute(fd, filename, name)
    } else if options.cflag {
      return clear_all_attributes(fd, filename);
    } else if options.pflag {
      return read_attribute(fd, filename, name);
    } else {
      return list_all_attributes(fd, filename);
    }
  }

  let long_opts: [CMigration.option] = [
    option("help", .no_argument),
  ]



  func parseOptions() async throws(CmdErr) -> CommandOptions {
    var opts = CommandOptions()
    //    while ((ch = getopt(argc, argv, "HLPRfhvx")) != -1)
    let go = BSDGetopt_long("hclrspwdvx", long_opts)
    while let (k,_) = try go.getopt_long() {
      switch k {


          /*          prgname = basename((char *)argv[0]);
           if (!prgname) {
           prgname = argv[0];
           }
           */

        case "help", "h":
          var stderr = FileDescriptor.standardError
          print(usage, to: &stderr)
        case "c":
          opts.cflag = true
          if let m = opts.main_opt, m != k {
            throw CmdErr(1, "Cannot specify -\(k) with -\(m)")
          }
          opts.main_opt = k
          opts.req_args = 1
        case "l":
          opts.lflag = true
        case "r":
          opts.rflag = true
        case "s":
          opts.sflag = true
        case "p":
          opts.pflag = true
          if let m = opts.main_opt, m != k {
            throw CmdErr(1, "Cannot specify -\(k) with -\(m)")
          }
          opts.main_opt = k
          opts.req_args = 2

        case "w":
          opts.wflag = true
          if let m = opts.main_opt, m != k {
            throw CmdErr(1, "Cannot specify -\(k) with -\(m)")
          }
          opts.main_opt = k
          opts.req_args = 3

        case "d":
          opts.dflag = true
          if let m = opts.main_opt, m != k {
            throw CmdErr(1, "Cannot specify -\(k) with -\(m)")
          }
          opts.main_opt = k
          opts.req_args = 2

        case "v":
          opts.vflag = true
        case "x":
          opts.xflag = true
        case "?":
          // getopt_long() will print an error message when it fails to parse
          throw CmdErr(1)
        default:
          throw CmdErr(1)
      }
    }
    opts.args = go.remaining

    if opts.lflag && (opts.wflag || opts.dflag) {
      throw CmdErr(1, "-l is not allowed with -w or -d")
    }

    if opts.main_opt == nil {
      // Default mode is to list all attributes. We expect at least one file path
      opts.req_args = 1
    }

    if opts.args.count < opts.req_args {
      throw CmdErr(1, "Not enough arguments for option -\(opts.main_opt!). Expected at least \(opts.req_args) but got \(opts.args.count)")
    }

    if opts.pflag || opts.wflag || opts.dflag {
      opts.attr_name = opts.args.removeFirst()
    }

    if opts.wflag {
      opts.attr_value = opts.args.removeFirst()
    }

    opts.nfiles = opts.args.count
    return opts
  }

  func runCommand() async throws(CmdErr) {
    // nfiles = (argc - argind);
    var status = 0

    for filename in options.args {
      if process_one_path(filename, options.attr_name, options.attr_value) {
        status = 1
      }
    }

    if status == 1 {
      throw CmdErr(1, "")
    }
  }
}


