// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1983, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Darwin

@main struct mkdir : ShellCommand {


  // int ch, exitval, success, pflag;
  // mode_t omode;
  // void *set = NULL;

  // omode = pflag = 0;

  // var vflag : Bool = false

  struct CommandOptions {
    var mode : String?
    var pflag : Bool = false
    var vflag : Bool = false
    var args : [String] = []
    var omode : mode_t = 0
  }

  var options : CommandOptions!

  func parseOptions() throws(CmdErr) -> CommandOptions {
    var opts = CommandOptions()
    let go = BSDGetopt("m:pv")
    while let (k,v) = try go.getopt() {
      switch k {
      case "m":
        opts.mode = v
      case "p":
        opts.pflag = true
      case "v":
        opts.vflag = true
      case "?":
        fallthrough
      default:
        throw CmdErr(1)
      }
    }

    opts.args = go.remaining
    if opts.args.isEmpty {
      throw CmdErr(1)
    }


    if opts.mode == nil {
      opts.omode = S_IRWXU | S_IRWXG | S_IRWXO
    } else {
      let set = Darwin.setmode(opts.mode)
      if set == nil {
        throw CmdErr(1, "invalid file mode: \(opts.mode ?? "")");
      }
      opts.omode = Darwin.getmode(set, S_IRWXU | S_IRWXG | S_IRWXO);
      free(set);
    }
    return opts
  }

  func runCommand() async throws(CmdErr) {
    var success = 0
    var exitval = 0
    for tap in options.args {
      let ta = FilePath(tap)
      if options.pflag {
        success = build(ta.string, options.omode, options.vflag);
      } else if (Darwin.mkdir(ta.string, options.omode) < 0) {
        if (errno == ENOTDIR || errno == ENOENT) {
          let j = ta.removingLastComponent()
          warnx(j.string)
/*          ta.withCString { n in
            let k = strdup(n)
            if let j = Darwin.dirname(k) {
              warnx(String(validatingCString: j) ?? "??" )
            }
            free(k)
          }
 */
        }
        else {
          warnx(ta.string)
        }
        success = 0;
      } else {
        success = 1;
        if options.vflag {
          print(ta.string);
        }
      }
      if success == 0 {
        exitval = 1
      }

      /*
       * The mkdir() and umask() calls both honor only the low
       * nine bits, so if you try to set a mode including the
       * sticky, setuid, setgid bits you lose them.  Don't do
       * this unless the user has specifically requested a mode,
       * as chmod will (obviously) ignore the umask.  Do this
       * on newly created directories only.
       */
      if (success == 1 && options.mode != nil && Darwin.chmod(ta.string, options.omode) == -1) {
        warnx(ta.string)
        exitval = 1;
      }
    }
    Darwin.exit(Int32(exitval))
  }


  /*
   * Returns 1 if a directory has been created,
   * 2 if it already existed, and 0 on failure.
   */
  func build(_ path : String, _ omode : mode_t, _ verbose : Bool) -> Int {
    var sb : stat = Darwin.stat()
    var oumask : mode_t = 0
    var retval = 1

    var pp = path.split(separator: "/", omittingEmptySubsequences: false)
    if pp.first?.isEmpty == true { // Skip leading
      pp.removeFirst()
    }

    if pp.last?.isEmpty == true { // remove final /
      pp.removeLast()
    }

    /*
     * POSIX 1003.2:
     * For each dir operand that does not name an existing
     * directory, effects equivalent to those caused by the
     * following command shall occcur:
     *
     * mkdir -p -m $(umask -S),u+wx $(dirname dir) &&
     *    mkdir [-m mode] dir
     *
     * We change the user's umask and then restore it,
     * instead of doing chmod's.
     */
    oumask = Darwin.umask(0);
    let numask = oumask & ~(S_IWUSR | S_IXUSR)
    Darwin.umask(numask)

    while pp.last?.isEmpty == true { pp.removeLast() }

    for p in 0..<pp.count {
      let pth = pp[0...p].joined(separator: "/")
      let last = p == pp.count - 1
      if Darwin.mkdir(pth, last ? omode : S_IRWXU | S_IRWXG | S_IRWXO) < 0 {
        if (errno == EEXIST || errno == EISDIR) {
          if stat(pth, &sb) < 0 {
            warnx(pth)
            retval = 0
            break
          } else if (!S_ISDIR(sb.st_mode)) {
            if last {
              errno = EEXIST
            }
            else {
              errno = ENOTDIR
            }
            warnx(pth)
            retval = 0
            break
          }
          if last {
            retval = 2
          }
        } else {
          warnx(pth)
          retval = 0
          break
        }
      } else if verbose {
        print(pth)
      }
    }
    Darwin.umask(oumask);
    return retval
  }

  var usage = "usage: mkdir [-pv] [-m mode] directory_name ..."
}
