// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Darwin

// #ifndef AT_REMOVEDIR_DATALESS

let AT_REMOVEDIR_DATALESS = Int32(0x0100)  /* Remove a dataless directory without materializing first */

//#endif
/*
 #else
#define COMPAT_MODE(func, mode) 1
#endif
*/

/*
static int dflag, eval, fflag, iflag, Pflag, vflag, Wflag, stdin_ok;
static int rflag, Iflag, xflag;
static uid_t uid;
 */
var info : sig_atomic_t = 0
var stdin_ok = false
let unix2003 = true

// from /usr/include/removefile.h
var REMOVEFILE_SECURE_7_PASS = (1 << 2)        // 7 pass DoD algorithm

/*
 * rm --
 *	This rm is different from historic rm's, but is expected to match
 *	POSIX 1003.2 behavior.	The most visible difference is that -f
 *	has two specific effects now, ignore non-existent files and force
 *	file removal.
 */
@main struct rm : ShellCommand {

  struct CommandOptions {
    var dflag = false
    var eval = false
    var fflag = false
    var iflag = false
    var Pflag = false
    var vflag = false
    var Wflag = false
    var rflag = false
    var Iflag = false
    var xflag = false
    var ieval : Int32 = 0
    var uid : UInt32 = 0
    var args : [String] = []
  }

  var options : CommandOptions!

  /*
   int ch;
   char *p;

   #ifdef __APPLE__
   if (argc < 1)
   usage();
   #endif

   (void)setlocale(LC_ALL, "");
   */

  /*
   * Test for the special case where the utility is called as
   * "unlink", for which the functionality provided is greatly
   * simplified.
   */

  /*
   if ((p = strrchr(argv[0], '/')) == NULL)
   p = argv[0];
   else
   ++p;
   */

  func parseOptions() throws(CmdErr) -> CommandOptions {

    // FIXME: split the command
    /* Note that rm_file() uses uid. */
    /*
     if (strcmp(p, "unlink") == 0) {
     if (argc == 2)
     rm_file(&argv[1]);
     else if (argc == 3 && strcmp(argv[1], "--") == 0)
     rm_file(&argv[2]);
     else
     usage();
     exit(eval);
     }
     */
    var options = CommandOptions()
    options.uid = geteuid();

    var go = BSDGetopt("dfiIPRrvWx")
    while let (k, v) = try go.getopt() {
      switch k {
        case "d":
          options.dflag = true
        case "f":
          options.fflag = true
          options.iflag = false
        case "i":
          options.fflag = false
          options.iflag = true
        case "I":
          options.Iflag = true
        case "P":
          // #ifdef __APPLE__
          options.Pflag = true
          // #else
          /* Compatibility no-op. */
          // #endif
        case "R", "r": /* Compatibility. */
          options.rflag = true
        case "v":
          options.vflag = true
        case "W":
          options.Wflag = true
        case "x":
          options.xflag = true
        default:
          throw CmdErr(1)
      }
    }
    options.args = go.remaining
    if options.args.isEmpty {
      if !options.fflag {
        throw CmdErr(1)
      }
    }
    let k = checkdot(options.args)
    if k.count != options.args.count {
      options.ieval = 1
    }
    options.args = k
    checkslash(&options.args)
    if options.args.isEmpty {
      if !options.fflag {
        throw CmdErr(1)
      }
    }
    return options
  }

  func runCommand() async throws(CmdErr) {
    var eval : Int32 = options.ieval

    if options.args.isEmpty {
      if options.fflag {
        return
      }
    }

    signal(SIGINFO, siginfo)
    if !options.args.isEmpty {
      stdin_ok = isatty(STDIN_FILENO) != 0

      if options.Iflag {
        if !check2(options.args) {
          exit(1)
        }
      }
      if options.rflag {
        rm_tree(options.args)
      } else {
        rm_file(options.args, &eval)
      }
    }

    exit(eval)
  }

  func rm_tree(_ args : [String]) {
    /*	FTS *fts;
     FTSENT *p;
     int needstat;
     int flags;
     int rval;
     */
    //	int wantConformance = unix2003 //  COMPAT_MODE("bin/rm", "unix2003");
    /*
     * Remove a file hierarchy.  If forcing removal (-f), or interactive
     * (-i) or can't ask anyway (stdin_ok), don't stat the file.
     */
    let needstat = options.uid == 0 || (!options.fflag && !options.iflag && stdin_ok)

    /*
     * If the -i option is specified, the user can skip on the pre-order
     * visit.  The fts_number field flags skipped directories.
     */
    let SKIPPED = 1

    var flags = FTSFlags.PHYSICAL
    if (!needstat) {
      flags.insert(.NOSTAT)
    }
    if options.Wflag {
      flags.insert(.WHITEOUT)
    }
    if options.xflag {
      flags.insert(.XDEV)
    }
    guard let fts = try? FTSWalker(path: options.args, options: flags, sort: nil) else {
      if options.fflag && errno == ENOENT {
        return
      }
      err(1, "fts_open")
    }

    var eval : Int32 = 0

    for var p in fts {
      //	while ((void)(errno = 0), (p = fts_read(fts)) != NULL) {
      switch p.info {
        case .DNR:
          if !options.fflag || p.errno.code != ENOENT {
            warnx("\(p.path): \(p.errno.localizedDescription)")
            eval = 1
          }
          continue
        case .ERR:
          errx(1, "\(p.path): \(p.errno.localizedDescription)")
        case .NS:
          /*
           * Assume that since fts_read() couldn't stat the
           * file, it can't be unlinked.
           */
          if (!needstat) {
            break
          }
          if !options.fflag || p.errno.code != ENOENT {
            warnx("\(p.path): \(p.errno.localizedDescription)")
            eval = 1
          }
          continue
        case .D:
          /* Pre-order: give user chance to skip. */
          /* In conformance mode the user is prompted to skip processing the contents.
           * Then the option to delete the dir is presented post-order */
          if (!options.fflag &&
              ( (unix2003 && !checkdir(p.path)) ||
                (!unix2003 && !check(p.path, p.accpath, p.statp!))
              )
          ) {
            p.setAction(.SKIP)
            p.number = SKIPPED
          }
          else if (options.uid == 0 &&
                   (p.statp!.flags.contains(.UF_APPEND) ||
                    p.statp!.flags.contains(.UF_IMMUTABLE)) &&
                   !(p.statp!.flags.contains(.SF_APPEND) ||
                     p.statp!.flags.contains(.SF_IMMUTABLE)) &&
                   lchflags(p.accpath,
                            p.statp!.flags.subtracting([.UF_APPEND, .UF_IMMUTABLE]).rawValue) < 0) {
            warn(p.path)
            eval = 1
          }
          continue
        case .DP:
          /* Post-order: see if user skipped. */
          if (p.number == SKIPPED) { /*in legacy mode, the user was prompted pre-order */
            continue
          } else if (unix2003) {
            /* delete directory if force is on, or if user answers Y to prompt */
            if (options.fflag || check(p.path, p.accpath, p.statp!)) {
              break
            } else {
              continue
            }
          }
        default:
          if (!options.fflag &&
              !check(p.path, p.accpath, p.statp!)) {
            continue
          }
      }

      var rval : Int32 = 0
      if (options.uid == 0 &&
          (p.statp!.flags.contains(.UF_APPEND) ||
           p.statp!.flags.contains(.UF_IMMUTABLE)) &&
          !(p.statp!.flags.contains(.SF_APPEND) ||
            p.statp!.flags.contains(.SF_IMMUTABLE))) {
        rval = lchflags(p.accpath,
                        p.statp!.flags.subtracting([.UF_APPEND, .UF_IMMUTABLE]).rawValue)
      }
      if (rval == 0) {
        /*
         * If we can't read or search the directory, may still be
         * able to remove it.  Don't print out the un{read,search}able
         * message unless the remove fails.
         */
        switch (p.info) {
          case .DP, .DNR:
            // #if __APPLE__
            rval = unlinkat(AT_FDCWD, p.accpath, AT_REMOVEDIR_DATALESS);
            if (rval == -1 && errno == EINVAL) {
              /*
               * Kernel rejected AT_REMOVEDIR_DATALESS?
               * I guess we fall back on the painful
               * route (but it's better than failing).
               */
              rval = rmdir(p.accpath)
            }
            // #else
            // 				rval = rmdir(p->fts_accpath);
            // #endif
            if (rval == 0 || (options.fflag && errno == ENOENT)) {
              if (rval == 0 && options.vflag) {
                print(p.path)
              }
              if (rval == 0 && info != 0) {
                info = 0;
                print(p.path)
              }
              continue
            }

            if (rval == -1) {
              if (errno == ENOTEMPTY && p.errno.code == EACCES) {
                /*
                 * If we reach this point, it means that we either failed to
                 * list the dir entities, or FTS failed to chdir to a child directory.
                 * Anyway, this case should be EACCES.
                 */
                errno = EACCES;
              }
            }
          case .W:
            rval = undelete(p.accpath);
            if (rval == 0 && (options.fflag && errno == ENOENT)) {
              if options.vflag {
                print(p.path)
              }
              if info != 0 {
                info = 0;
                print(p.path)
              }
              continue
            }
          case .NS:
            /*
             * Assume that since fts_read() couldn't stat
             * the file, it can't be unlinked.
             */
            if options.fflag {
              continue
            }
            /* FALLTHROUGH */
            fallthrough
          case .F, .NSOK:
            fallthrough
          default:
            // #ifdef __APPLE__
            if options.Pflag {
              if (removefile(p.accpath, NULL, REMOVEFILE_SECURE_7_PASS)) { /* overwrites and unlinks */
                eval = 1
                rval = 1
              }
            } else {
              rval = unlink(p.accpath);
            }
            // #else  /* !__APPLE_ */
            // 				rval = unlink(p->fts_accpath);
            // #endif	/* __APPLE__ */
            if (rval == 0 || (options.fflag && errno == ENOENT)) {
              if (rval == 0 && options.vflag) {
                print(p.path)
              }
              if rval == 0 && info != 0 {
                info = 0
                print(p.path)
              }
              continue
            }
        }
      }
      warn(p.path)
      eval = 1
    }
    if !options.fflag && errno != 0 {
      err(1, "fts_read")
    }
  }

  func rm_file(_ args : [String], _ eval : inout Int32 ) {
    //	struct stat sb;
    var rval : Int32 = 0
    //	char *f;

    /*
     * Remove a file.  POSIX 1003.2 states that, by default, attempting
     * to remove a directory is an error, so must always stat the file.
     */
    for f in args {
      /* Assume if can't stat the file, can't unlink it. */
      guard let sb = try? FileMetadata(for: f, followSymlinks: false) else {
        if options.Wflag {
          sb.st_mode = S_IFWHT|S_IWUSR|S_IRUSR;
        } else {
          if (!options.fflag || errno != ENOENT) {
            warn(f)
            eval = 1
          }
          continue;
        }
      }
      if options.Wflag {
        let z = strerror(EEXIST)!
        warnx("\(f): \(z)")
        eval = 1
        continue
      }

      if sb.fileType == .directory && !options.dflag {
        warnx("\(f): is a directory")
        eval = 1
        continue
      }
      if (!options.fflag && sb.fileType != .whiteOut && !check(f, f, sb)) {
        continue
      }
      rval = 0
      if (options.uid == 0 && sb.fileType != .whiteOut &&
          (sb.flags.contains(.UF_APPEND) ||
           sb.flags.contains(.UF_IMMUTABLE)) &&
          !(sb.flags.contains([.SF_APPEND, .SF_IMMUTABLE]))) {
        rval = lchflags(f, sb.flags.subtracting([.UF_APPEND, .UF_IMMUTABLE]).rawValue)
      }
      if (rval == 0) {
        if (sb.fileType == .whiteOut) {
          rval = undelete(f);
        }
        else if sb.fileType == .directory {
          rval = rmdir(f)
        }
        else {
          // #ifdef __APPLE__
          if options.Pflag {
            if (removefile(f, nil, REMOVEFILE_SECURE_7_PASS)) { /* overwrites and unlinks */
              eval = 1
              rval = 1
            }
          } else {
            rval = unlink(f)
          }
          // #else  /* !__APPLE__ */
          //				rval = unlink(f);
          // #endif	/* __APPLE__ */
        }
      }
      if (rval != 0 && (!options.fflag || errno != ENOENT)) {
        warn(f)
        eval = 1
      }
      if (options.vflag && rval == 0) {
        print(f)
      }
      if (info != 0 && rval == 0) {
        info = 0
        print(f)
      }
    }
  }

  func yes_or_no() -> Bool {
    let lin = readLine()

    var buf = [UInt8](repeating: 0, count: 2)
    buf[1] = 0
    if let z = lin?.first?.utf8.first {
      /* only care about the first character */
      buf[0] = z
      return Darwin.rpmatch(&buf) == 1
    }
    return false

  }

  func checkdir(_ path : String) -> Bool {
    if (!options.iflag) {
      return true	//if not interactive, process directory's contents
    }
    var stderr = FileDescriptor.standardError
    print("examine files in directory \(path)? ", terminator: "", to: &stderr)
    return yes_or_no()
  }

  func check(_ path : String, _ name : String, _ sp : FileMetadata) -> Bool {
    //	char modep[15], *flagsp;

    var stderr = FileDescriptor.standardError
    /* Check -i first. */
    if options.iflag {
      print("remove \(path)? ", terminator: "", to: &stderr)
    }
    else {
      /*
       * If it's not a symbolic link and it's unwritable and we're
       * talking to a terminal, ask.  Symbolic links are excluded
       * because their permissions are meaningless.  Check stdin_ok
       * first because we may not have stat'ed the file.
       */
      if (!options.stdin_ok || sp.fileType == .symbolicLink ||
          (access(name, W_OK) == 0 &&
           !(sp.flags.contains(.SF_APPEND) || sp.flags.contains(.SF_IMMUTABLE)) &&
           (!(sp.flags.contains(.UF_APPEND) || sp.flags.contains(.UF_IMMUTABLE)) || options.uid == 0))) {
        return true
      }
      let modep = strmode(sp.fileType, sp.mode)

      guard let flagsp = fflagstostr(sp.flags) else {
        err(1, "fflagstostr")
      }
      let u = user_from_uid( UInt32(sp.userId), 0)!
      let g = group_from_gid( UInt32(sp.groupId), 0)!

      print("override \(modep.dropFirst())\(modep.last == " " ? "" : " ")\(u)/\(g) \(flagsp)\(flagsp.isEmpty ? " " : "")for \(path)? ")
    }
    return yes_or_no();
  }

  func checkslash(_ argv : inout [String]) {
    var z = argv.filter { $0 != "/" }
    if z.count < argv.count {
      warnx("\"/\" may not be removed");
    }
    argv = z
  }

  func check2(_ args : [String]) -> Bool {
    //	int ch;
    var fcount = 0
    var dcount = 0
    //	int i;
    var dname : String? = nil

    for arg in args {
      if let st = try? FileMetadata(for: arg, followSymlinks: false) {
        if st.fileType == .directory { // (S_ISDIR(st.st_mode)) {
          dcount += 1
          dname = arg    /* only used if 1 dir */
        } else {
          fcount += 1
        }
      }
    }
    var first = ""
    var stderr = FileDescriptor.standardError
    while (first != "n" && first != "N" && first != "y" && first != "Y") {
      if dcount > 0 && options.rflag {
        print("recursively remove", terminator: "", to: &stderr)
        if dcount == 1 {
          print(" \(dname!)", terminator: "", to: &stderr)
        }
        else {
          print(" \(dcount) dirs", terminator: "", to: &stderr)
        }
        if fcount == 1 {
          print(" and 1 file", terminator: "", to: &stderr)
        }
        else if fcount > 1 {
          print(" and \(fcount) files", terminator: "", to: &stderr)
        }
      } else if (dcount + fcount > 3) {
        print("remove \(dcount+fcount) files", terminator: "", to: &stderr)
      } else {
        return true
      }
      print("? ", terminator: "", to: &stderr)
      //		fflush(stderr);

      guard let lin = readLine() else {
        break
      }
      first = String(lin.first ?? " ")
    }
    return first == "y" || first == "Y"
  }

// #define ISDOT(a)	((a)[0] == '.' && (!(a)[1] || ((a)[1] == '.' && !(a)[2])))

  func checkdot(_ args : [String]) -> [String] {
    var complained = false
    var result : [String] = []
    for t in args {
      let p = t.split(separator: "/", omittingEmptySubsequences: true).last ?? ""
      if p == "." || p == ".." {
        if !complained {
          complained = true
          warnx("\".\" and \"..\" may not be removed")
        }
        continue
      } else {
        result.append(t)
      }
    }
    return result
  }

var usage = """
usage: rm [-f | -i] [-dIPRrvWx] file ...
       unlink [--] file
"""
}

func siginfo(_ sig : Int32) {
	info = 1
}
