// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1987, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Darwin

@main class ln : ShellCommand {

  struct CommandOptions {
    var fflag = false			/* Unlink existing files. */
    var Fflag = false			/* Remove empty directories also. */
    var hflag = false			/* Check new name for symlink first. */
    var iflag = false			/* Interactive mode. */
    var Pflag = false			/* Create hard links to symlinks. */
    var sflag = false			/* Symbolic, not hard, link. */
    var vflag = false			/* Verbose output. */
    var wflag = false			/* Warn if symlink target does not
                           * exist, and -f is not enabled. */
    var args = [String]()
    var linkch = ">"
  }

  var options : CommandOptions!

  var targetdir : String?

  required init() {
  }

  //    static char	linkch;


  //	struct stat sb;
  //	char *targetdir;
  //	int ch, exitval;

  /*
   * Test for the special case where the utility is called as
   * "link", for which the functionality provided is greatly
   * simplified.
   */
  func parseOptions() throws(CmdErr) -> CommandOptions {
    var options = CommandOptions()
    let go = BSDGetopt("FLPfhinsvw")
    while let (k, v) = try go.getopt() {
      switch(k) {
        case "F":
          options.Fflag = true
        case "L":
          options.Pflag = false
        case "P":
          options.Pflag = true
        case "f":
          options.fflag = true
          options.iflag = false
          options.wflag = false
        case "h", "n":
          options.hflag = true
        case "i":
          options.iflag = true
          options.fflag = false
        case "s":
          options.sflag = true
        case "v":
          options.vflag = true
        case "w":
          options.wflag = true
        case "?":
          fallthrough
        default:
          throw CmdErr(1)
      }
    }

    options.args = go.remaining

    options.linkch = options.sflag ? "-" : "="
    if !options.sflag {
      options.Fflag = false
    }
    if options.Fflag && !options.iflag {
      options.fflag = true
      options.wflag = false		/* Implied when fflag is true */
    }
    options.args = go.remaining
    return options
  }

  func runCommand() async throws(CmdErr) {
    switch options.args.count {
      case 0:
        throw CmdErr(1)
        /* NOTREACHED */
      case 1:				/* ln source */
        exit(linkit(options.args[0], ".", true))
      case 2:				/* ln source target */
        exit(linkit(options.args[0], options.args[1], false))
      default:
        break
    }
    /* ln source1 source2 directory */

    targetdir = options.args.removeLast()
    
    if options.hflag {
        if let fm = try? FileMetadata(for: targetdir!, followSymlinks: false),
           fm.filetype == .symbolicLink {
          /*
           * We were asked not to follow symlinks, but found one at
           * the target--simulate "not a directory" error
           */
          errno = ENOTDIR
          err(1, targetdir)
        }
    }
    do {
      let fm = try FileMetadata(for: targetdir!)
      if fm.filetype != .directory {
        throw CmdErr(1, usage)
      }
    } catch(let e) {
      err(1, targetdir)
    }
    var exitval : Int32 = 0
    for argv in options.args {
      exitval = max(exitval, linkit(argv, targetdir!, true))
    }
    exit(exitval)
  }

  /*
   * Two pathnames refer to the same directory entry if the directories match
   * and the final components' names match.
   */
  func samedirent(_ path1 : String, _ path2 : String) -> Bool {
//    const char *file1, *file2;
//    char pathbuf[PATH_MAX];
//    struct stat sb1, sb2;

    if path1 == path2 { return true }

    // stuff after the last /
    let file1 = FilePath(path1).lastComponent!.string
    let file2 = FilePath(path2).lastComponent!.string

    if file1 != file2 { return false }

    if path1.count >= PATH_MAX || path2.count >= PATH_MAX  { return false}

    var pathbuf : String = ""
    if file1 == path1 { pathbuf = "."}
    else {
      var p = FilePath(path1)
      p.removeLastComponent()
      pathbuf = p.string
    }
    guard let sb1 = try? FileMetadata(for: pathbuf) else {
      return false
    }
    if file2 == path2 { pathbuf = "." }
    else {
      var p = FilePath(path2)
      p.removeLastComponent()
      pathbuf = p.string
    }

    guard let sb2 = try? FileMetadata(for: pathbuf) else {
      return false
    }
    return sb1.device == sb2.device && sb1.inode == sb2.inode
  }

  func isDirectory(_ path : String, followSymlinks: Bool = true) -> Bool {
    if let fm = try? FileMetadata(for: path, followSymlinks: followSymlinks) {
      if fm.filetype == .directory { return true }
    }
    return false
  }

  func linkit(_ source : String, _ targetx : String, _ isdir : Bool) -> Int32 {
//    char path[PATH_MAX];
//    char wbuf[PATH_MAX];
//    char bbuf[PATH_MAX];
//    struct stat sb;
//    const char *p;
//    int ch, first;
//    bool exists;

    var target = targetx
    if !options.sflag {
      /* If source doesn't exist, quit now. */
      guard let fm = try? FileMetadata(for: source, followSymlinks: !options.Pflag) else {
        warn(source);
        return 1
      }
      /* Only symbolic links to directories. */
      if fm.filetype == .directory {
        errno = EISDIR
        warn(source);
        return 1
      }
    }

    /*
     * If the target is a directory (and not a symlink if hflag),
     * append the source's name, unless Fflag is set.
     */
    if !options.Fflag && (isdir || isDirectory(target, followSymlinks: false) ||
                          (!options.hflag && isDirectory(target, followSymlinks: true))) {
      let p = FilePath(source).lastComponent!.string
      let path = "\(target)/\(p)"
/*      if path > MAXPATHLEN {
        errno = ENAMETOOLONG
        warn(source)
        return 1
      }*/
       target = path;
      }

    /*
     * If the link source doesn't exist, and a symbolic link was
     * requested, and -w was specified, give a warning.
     */
    if options.sflag && options.wflag {
      if source.first == "/" {
        /* Absolute link source. */
        let fm = try? FileMetadata(for: source)
        if let fm {
        } else {
          warn("warning: \(source) inaccessible")
        }
      } else {
        /*
         * Relative symlink source.  Try to construct the
         * absolute path of the source, by appending `source'
         * to the parent directory of the target.
         */

        let wbuf = FilePath(target).removingLastComponent().appending(source)
        let fm = try? FileMetadata(for: wbuf.string)
        if let fm {
        } else {
            warn("warning: \(source)")
          }
        }
      }

    /*
     * If the file exists, first check it is not the same directory entry.
     */
    let fm = try? FileMetadata(for: target, followSymlinks: false)
    let exists = fm != nil
    if exists {
      if !options.sflag && samedirent(source, target) {
        warnx("\(source) and \(target) are the same directory entry")
        return 1
      }
    }
    /*
     * Then unlink it forcibly if -f was specified
     * and interactively if -i was specified.
     */
    if options.fflag && exists {
      if options.Fflag && fm!.filetype == .directory {
        if rmdir(target) != 0 {
          warn(target)
          return 1
        }
      } else if unlink(target) != 0 {
        warn(target)
        return 1
      }
    } else if options.iflag && exists {
      fflush(stdout)
      var stderr = FileDescriptor.standardError
      print("replace \(target)? ", terminator: "", to: &stderr)

      let lin = readLine() ?? ""
      if !(lin.first == "y" || lin.first == "Y") {
        var stderr = FileDescriptor.standardError
        print("not replaced", to: &stderr)
        return 1
      }

      if options.Fflag && fm!.filetype == .directory {
        if rmdir(target) != 0 {
          warn(target)
          return 1
        }
      } else if unlink(target) != 0 {
        warn(target);
        return 1
      }
    }

    /* Attempt the link. */
    if options.sflag ? (Darwin.symlink(source, target) != 0) :
          (linkat(AT_FDCWD, source, AT_FDCWD, target,
                 options.Pflag ? 0 : AT_SYMLINK_FOLLOW) != 0 ) {
      warn(target)
      return 1
    }
    if options.vflag {
      print("\(target) \(options.linkch)> \(source)")
    }
    return 0
  }

  var usage : String = """
usage: ln [-s [-F] | -L | -P] [-f | -i] [-hnv] source_file [target_file]
       ln [-s [-F] | -L | -P] [-f | -i] [-hnv] source_file ... target_dir
"""
}
