// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

import CMigration
import Darwin

func cp_pct(_ x : Int, _ y : Int) -> Int {
  return y == 0 ? 0 : 100 * x / y
}

  /*
   * Memory strategy threshold, in pages: if physmem is larger then this, use a
   * large buffer.
   */
  let PHYSPAGES_THRESHOLD = (32*1024)

  /* Maximum buffer size in bytes - do not allow it to grow larger than this. */
  let BUFSIZE_MAX = (2*1024*1024)

  /*
   * Small (default) buffer size in bytes. It's inefficient for this to be
   * smaller than MAXPHYS.
   */
  let BUFSIZE_SMALL = (MAXPHYS)

  /*
   * Prompt used in -i case.
   */
  let YESNO = "(y/n [n]) "


extension cp {
  func copy_fallback(_ from_fd : FileDescriptor, _ to_fd : FileDescriptor) -> Int {
/*    static char *buf = NULL;
    static size_t bufsize;
    ssize_t rcount, wresid, wcount = 0;
    char *bufp;
*/
    do {
      let bufsize = min(BUFSIZE_MAX, Int(MAXPHYS) * 8)
      var buf = try from_fd.readUpToCount(bufsize)
      //    rcount = read(from_fd, buf, bufsize);
      let rcount = buf.count
      if rcount == 0 { return 0 }
      while buf.count > 0 {
        let n = try to_fd.write(buf)
        buf = Array(buf.dropFirst(n))
      }
      return rcount
    } catch(let e) {
      return -1
    }
  }


  func copy_file(_ entp : FtsEntry, _ dnex : Bool, _ target : String) -> Bool {
//    struct stat to_stat;
//    struct copyfile_context cpctx;
//    copyfile_state_t cpfs;

//    struct stat sb, *fs;
//    ssize_t wcount;
//    off_t wtotal;
//    int ch, checkch, from_fd, rval, to_fd;

//    char resp[] = {'\0', '\0'};
//    mode_t mode = 0;
//    int cpflags, ret, use_copy_file_range = 0;

    var rval = false

    let fs = entp.statp!
    // FIXME: MASSIVE KLUDGE
    var from_fd : FileDescriptor = FileDescriptor(rawValue: -1)
    var dne = dnex
    var topp = target

    if !options.lflag && !options.sflag {
      let sb : FileMetadata
      do {
        from_fd = try FileDescriptor(forReading: entp.path)
        let sbx = try FileMetadata(for: from_fd)
        sb = sbx
      } catch {
        warn(entp.path)
        return true
      }

      defer { try? from_fd.close() }
      /*
       * Check that the file hasn't been replaced with one of a
       * different type.  This can happen if we've been asked to
       * copy something which is actively being modified and
       * lost the race, or if we've been asked to copy something
       * like /proc/X/fd/Y which stat(2) reports as S_IFREG but
       * is actually something else once you open it.
       */

      /*
       * Additionally, guard against the possibility that a
       * symbolic link which is dangling when FTS sees it (so
       * fs->st_mode & S_IFMT is S_IFLNK) but is no longer
       * dangling by the time we get to it (so open() succeeds)
       * leads to something that turns out to be a symbolic link
       * after we open it (so sb.st_mode & S_IFMT is also
       * S_IFLNK, defeating the check).  This can't happen
       * upstream because O_SYMLINK does not exist there so
       * (fs->st_mode & S_IFMT) cannot be S_IFLNK.
       */
      if sb.filetype != fs.filetype || sb.filetype == .symbolicLink {
        warnx("\(entp.path): File changed")
        return true
      }
    }

    /*
     * If the file exists and we're interactive, verify with the user.
     * If the file DNE, set the mode to be the from file, minus setuid
     * bits, modified by the umask; arguably wrong, but it makes copying
     * executables work right and it's been that way forever.  (The
     * other choice is 666 or'ed with the execute bits on the from file
     * modified by the umask.)
     */
    var stderr = FileDescriptor.standardError

    if !dne {
      if options.nflag {
        if options.vflag {
          print("\(topp) not overwritten")
        }
        return true
      } else if options.iflag {
        print("overwrite \(topp)? \(YESNO)", terminator: "", to: &stderr)

        /* Load user specified locale */
//        setlocale(LC_MESSAGES, "");

        var checkch = readLine()

        /* only care about the first character */
        var resp : Array<UInt8> = [checkch!.first!.asciiValue!, 0]
        if (rpmatch(&resp) != 1) {
          print("not overwritten", to: &stderr)
          return true
        }
      }


      /*
       * POSIX requires us to try to overwrite the existing file
       * and unlink it only if overwriting fails, so we'll deal
       * with it later, unless we were asked to attempt either
       * clonefile(2), link(2), or symlink(2) (the latter two
       * only if the -f flag was also given).
       */
      if (!unix2003 || options.cflag || (options.fflag && (options.lflag || options.sflag))) {
        /* remove existing destination file */
        Darwin.unlink(topp)
        dne = true
      }
    }

    if options.cflag {
      let ret = clonefile(entp.path, topp, 0)
      if ret == 0 {
        return false
      }
      if (errno != ENOTSUP) {
        warn("\(topp): clonefile failed")
        return true
      }
    }

    if options.lflag {
      if (Darwin.link(entp.path, topp) != 0) {
        warn(topp)
        return true
      }
      return false
    }

    if options.sflag {
      if (symlink(entp.path, topp) != 0) {
        warn(topp)
        return true
      }
      return false
    }

    var to_fd : FileDescriptor?
    if (!dne) {
      /* overwrite existing destination file */
      to_fd = try? FileDescriptor.open(topp, .writeOnly, options: [.truncate])
      // open(to.p_path, O_WRONLY | O_TRUNC, 0);

      /*
       * The file already exists, but we failed to open and
       * truncate it.  If -f was specified, try to remove it,
       * and if successful, set the dne flag so we go on to try
       * to create it below.  We save and restore errno so that
       * if unlink() fails, we'll later print the error from
       * open() rather than the one from unlink().
       */
      if to_fd == nil && options.fflag {
        let saved_errno = errno
        if (Darwin.unlink(topp) == 0) {
          dne = true
        }
        errno = saved_errno
      }
    }
    if dne {
      /* create new destination file */
      to_fd = try? FileDescriptor.open(topp, .writeOnly, options: [.create, .truncate],
                                  permissions: fs.permissions.subtracting([.setUserID, .setGroupID]))
    }
    if (to_fd == nil) {
      warn(topp)
      return true
    }

    if fs.filetype == .regular {
//      struct statfs sfs;

      /*
       * Pre-allocate blocks for the destination file if it
       * resides on Xsan.
       */
      var sfs = statfs()

      if fstatfs(to_fd!.rawValue, &sfs) == 0 {
        let fstn = withUnsafePointer(to: sfs.f_fstypename) {
          $0.withMemoryRebound(to: CChar.self, capacity: Int(NAME_MAX)) {
            String(cString: $0)
          }
        }
        if fstn == "acfs" {
          var fst = fstore_t.init(fst_flags: 0, fst_posmode: F_PEOFPOSMODE, fst_offset: 0, fst_length: off_t(fs.size), fst_bytesalloc: off_t(fs.size))
          let _ = fcntl(to_fd!.rawValue, F_PREALLOCATE, &fst)
        }
      }
    }

    var mode : FilePermissions
    guard let to_stat = try? FileMetadata(for: to_fd!) else {
      warn(topp)
      return true
    }
//    if (fstat(to_fd, &to_stat) == 0) {
      mode = to_stat.permissions
    if ( 0 != (mode.rawValue & (S_IRWXG|S_IRWXO)) &&
          Darwin.fchmod(to_fd!.rawValue, mode.rawValue & ~(S_IRWXG|S_IRWXO)) != 0) {
        if (errno != EPERM) { /* we have write access but do not own the file */
          warn("\(topp): fchmod failed")
        }
        mode = []
      }

    /*
     * If we weren't asked to create a hard or soft link, and both the
     * source and the destination are regular files, use fcopyfile(3),
     * which has the ability to preserve holes if the source is sparse.
     */
    if fs.filetype == .regular && to_stat.filetype == .regular {
      /*
       * The documentation doesn't say, but copyfile_state_t is
       * a pointer to a struct, and copyfile_state_alloc() can
       * fail and return NULL.  The two copyfile_state_set()
       * calls below, on the other hand, merely assign values to
       * fields within the struct, and cannot fail.
       *
       * Note that we cannot use COPYFILE_STATE_SRC_FILENAME and
       * COPYFILE_STATE_DST_FILENAME to pass the filenames,
       * because if those are not NULL, copyfile_state_free()
       * will assume that the state was created by copyfile()
       * and will close the file descriptors!
       */
      if let cpfs = copyfile_state_alloc() {
        var cpctx = copyfile_context(src: entp.path, dst: topp, size: Int(fs.size), error: 0)

        copyfile_state_set(cpfs, UInt32(COPYFILE_STATE_STATUS_CTX), &cpctx)

        let _ = withUnsafePointer(to: copyfile_callback) {
          copyfile_state_set(cpfs, UInt32(COPYFILE_STATE_STATUS_CB), $0)
        }

        var cpflags = UInt32(COPYFILE_DATA)
        if !options.Sflag {
          cpflags |= UInt32(COPYFILE_DATA_SPARSE)
        }
        let ret = Darwin.fcopyfile(from_fd.rawValue, to_fd!.rawValue, cpfs, cpflags)
        copyfile_state_free(cpfs);
        if (ret != 0) {
          if (errno == ECANCELED) {
            errno = cpctx.error
          }
          warn("\(topp): fcopyfile failed")
          rval = true
        }
      } else {
        warn("\(topp): copyfile_state_alloc failed")
        rval = true
      }
    } else {
      var wtotal = 0
      var wcount = 0
      repeat {
        wcount = Int(copy_fallback(from_fd, to_fd!))
        wtotal += wcount
        if info != 0 {
          info = 0
          let k = cFormat("%3d", cp_pct(wtotal, Int(fs.size)))
          print("\(entp.path) -> \(topp) \(k)%", to: &stderr)
        }
      } while (wcount > 0);
      if (wcount < 0) {
        warn(entp.path)
        rval = true
      }

    }


    /*
     * Don't remove the target even after an error.  The target might
     * not be a regular file, or its attributes might be important,
     * or its contents might be irreplaceable.  It would only be safe
     * to remove it if we created it and its length is 0.
     */

    if (mode.rawValue != 0 && 0 != fchmod(to_fd!.rawValue, mode.rawValue)) {
      warn("\(topp): fchmod failed")
    }
    /* do these before setfile in case copyfile changes mtime */
    if !options.Xflag && fs.filetype == .regular  { /* skip devices, etc */
      if (Darwin.fcopyfile(from_fd.rawValue, to_fd!.rawValue, nil,
                    UInt32(COPYFILE_XATTR) ) < 0) {
        warn("\(entp.path): could not copy extended attributes to \(topp)")
        rval = true
      }
    }

    if options.pflag && setfile(fs, to_fd, target) {
      rval = true
    }

    /* If this ACL denies writeattr then setfile will fail... */
    if options.pflag && fcopyfile(from_fd.rawValue, to_fd!.rawValue, nil, UInt32(COPYFILE_ACL) ) < 0 {
      warn("\(entp.path): could not copy ACL to \(topp)")
      rval = true
    }

    guard let _ = try? to_fd?.close() else {
      warn(topp)
      rval = true
      return rval
    }

    return rval
  }

  func copy_link(_ p : FtsEntry, _ exists : Bool, _ target : String) -> Bool {
//    ssize_t len;
//    char llink[PATH_MAX];

    if exists && options.nflag {
      if options.vflag {
        print("\(target) not overwritten")
      }
      return true
    }

    var llink = Array(repeating: CChar(0), count: Int(PATH_MAX) )
    let len = readlink(p.path, &llink, llink.count - 1)

    if len == -1 {
      warn("readlink: \(p.path)")
      return true
    }
//    llink[len] = '\0';
    if exists && unlink(target) != 0 {
      warn("unlink: \(target)")
      return true
    }
    if symlink(llink, target) != 0 {
      warn("symlink: \(llink)")
      return true
    }

    if !options.Xflag {
      if (copyfile(p.path, target, nil, UInt32(COPYFILE_XATTR | COPYFILE_NOFOLLOW) ) < 0) {
        warn("\(p.path): could not copy extended attributes to \(target)")
        return true
      }
    }

    return options.pflag ? setfile(p.statp!, nil, target) : false
  }

  func copy_fifo(_ from_stat : FileMetadata, _ exists : Bool, _ target : String) -> Bool {

    if exists && options.nflag {
      if options.vflag {
        print("\(target) not overwritten")
      }
      return true
    }
    if exists && Darwin.unlink(target) != 0 {
      warn("unlink: \(target)")
      return true
    }
    if mkfifo(target, from_stat.permissions.rawValue) != 0 {
      warn("mkfifo: \(target)")
      return true
    }
    return options.pflag ? setfile(from_stat, nil, target) : false
  }

  func copy_special(_ from_stat : FileMetadata, _ exists : Bool, _ target : String) -> Bool {
    if exists && options.nflag {
      if options.vflag {
        print("\(target) not overwritten")
      }
      return true
    }
    if exists && Darwin.unlink(target) != 0 {
      warn("unlink: \(target)")
      return true
    }
    if mknod(target, from_stat.permissions.rawValue, Int32(from_stat.rawDevice)) != 0 {
      warn("mknod: \(target)")
      return true
    }
    return options.pflag ? setfile(from_stat, nil, target) : false
  }

  func setfile(_ fs : FileMetadata, _ fd : FileDescriptor?, _ target : String) -> Bool {
//    static struct timespec tspec[2];
//    struct stat ts;
//    int gotstat, islink, fdval;

    var rval = false
    let fdval = fd != nil
    let islink = !fdval && fs.filetype == .symbolicLink

    var fsmode = fs.permissions

    var tspec : [timespec] = [fs.lastAccess.timespec, fs.lastWrite.timespec]
    if 0 != (fdval ? Darwin.futimens(fd!.rawValue, &tspec) :
              utimensat(AT_FDCWD, target, &tspec, islink ? AT_SYMLINK_NOFOLLOW : 0)) {
      warn("utimensat: \(target)")
      rval = true
    }

    var ts : FileMetadata?
    if fdval {
      ts = try? FileMetadata(for: fd!)
    } else {
      ts = try? FileMetadata(for: target, followSymlinks: !islink)
    }

//    if (fdval ? fstat(fd, &ts) :
//          (islink ? lstat(to.p_path, &ts) : stat(topp, &ts)))
    let gotstat = ts != nil

    /*
     * Changing the ownership probably won't succeed, unless we're root
     * or POSIX_CHOWN_RESTRICTED is not set.  Set uid/gid before setting
     * the mode; current BSD behavior is to remove all setuid bits on
     * chown.  If chown fails, lose setuid/setgid bits.
     */
    if (!gotstat || fs.userId != ts!.userId || fs.groupId != ts!.groupId) {
      if 0 != (fdval ? Darwin.fchown(fd!.rawValue, UInt32(fs.userId), UInt32(fs.groupId)) :
                (islink ? Darwin.lchown(target, UInt32(fs.userId), UInt32(fs.groupId)) :
                  Darwin.chown(target, UInt32(fs.userId), UInt32(fs.groupId)))) {
        if (errno != EPERM) {
          let c = fdval ? "f" : (islink ? "l" : "")
          warn("\(c)chown: \(target)")
          rval = true
        }
        fsmode.remove([.setUserID, .setGroupID])
      }
    }

    if (!gotstat || fsmode != ts!.permissions) {
      if 0 != (fdval ? Darwin.fchmod(fd!.rawValue, fsmode.rawValue) :
                (islink ? Darwin.lchmod(target, fsmode.rawValue) :
                  Darwin.chmod(target, fsmode.rawValue))) {
        let c = fdval ? "f" : (islink ? "l" : "")
        warn("\(c)chmod: \(target)")
        rval = true
      }
    }

    if !options.Nflag && (!gotstat || fs.flags != ts!.flags) {
      if 0 != (fdval ?
               Darwin.fchflags(fd!.rawValue, fs.flags.rawValue) :
                (islink ? Darwin.lchflags(target, fs.flags.rawValue) :
                  Darwin.chflags(target, fs.flags.rawValue))) {
        /*
         * NFS doesn't support chflags; ignore errors unless
         * there's reason to believe we're losing bits.  (Note,
         * this still won't be right if the server supports
         * flags and we were trying to *remove* flags on a file
         * that we copied, i.e., that we didn't create.)
         */

        if ((errno != EPERM && errno != EOPNOTSUPP) || fs.flags.rawValue != 0) {

          warn("chflags: \(target)")
          rval = true
        }
      }
    }

    return rval
  }

}


/*
 * Context for fcopyfile() callback.
 */
struct copyfile_context {
  var src : String
  var dst : String
  var size : Int
  var error : Int32
}


typealias CopyfileCallback = @convention(c) (
    Int32, Int32, copyfile_state_t, UnsafePointer<CChar>?, UnsafePointer<CChar>?, UnsafeMutableRawPointer?
) -> Int32

// let copyfile_callback: CopyfileCallback = { what, stage, state, src, dst, ctx in

/*
 * Status callback for fcopyfile(), called after each write operation or
 * if an error occurs.  We use it to implement SIGINFO.
 */
// @convention(c) (Int32, Int32, copyfile_state_t?, UnsafePointer<CChar>?, UnsafePointer<CChar>?, UnsafeMutableRawPointer?) -> Int32
func copyfile_callback(_ what : Int32, _ stage : Int32, _ state : copyfile_state_t, _ src : UnsafePointer<CChar>?, _ dst : UnsafePointer<CChar>?, _ ctx : UnsafeMutableRawPointer?) -> Int32 {
  var cpctx = ctx!.assumingMemoryBound(to: copyfile_context.self).pointee
  var wtotal = 0

  if (stage == COPYFILE_ERR) {
    cpctx.error = errno
    return COPYFILE_QUIT
  }
  if (stage != COPYFILE_PROGRESS) {
    errx(1, "unexpected copyfile callback")
  }
  if (info != 0) {
    info = 0
    copyfile_state_get(state, UInt32(COPYFILE_STATE_COPIED), &wtotal);
    var stderr = FileDescriptor.standardError
    print("\(cpctx.src) -> \(cpctx.dst) \(cFormat("%3d", cp_pct(wtotal, cpctx.size)))%")
  }
  return (COPYFILE_CONTINUE);
}
