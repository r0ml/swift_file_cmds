// Generated by Robert M. Lefkowitz <r0ml@liberally.net> in 2025 using ChatGPT
// from a file containing the following notice:

/*-
 * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
 *
 * Copyright (c) 2000 Sheldon Hearn <sheldonh@FreeBSD.org>.
 * All rights reserved.
 *
 * Copyright (c) 2021 The FreeBSD Foundation
 *
 * Portions of this software were developed by Ka Ho Ng <khng@FreeBSD.org>
 * under sponsorship from the FreeBSD Foundation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

import CMigration
import Darwin
import SystemPackage

enum SimpleError: Error {
    case message(String)
}

@main struct truncate : ShellCommand {

  struct CommandOptions {
    var no_create: Bool = false
    var do_refer : Bool = false
    var rname : String?
    var rsize : Int = 0
    var do_relative = false
    var do_round = false
    var args : [String] = []
    var do_dealloc = false
    var do_truncate = true
    var got_size = false
    var sz = 0
  }

  /*
   struct stat sb;
   mode_t omode;
   #ifdef __APPLE__
   off_t oflow, rsize, sz, tsize, round;
   #else
   off_t oflow, rsize, sz, tsize, round, off, len;
   #endif
   uint64_t usz;
   int ch, error, fd, oflags, r;
   #ifndef __APPLE__
   int do_dealloc;
   #endif
   int do_truncate;
   int no_create;
   int do_relative;
   int do_round;
   int do_refer;
   int got_size;
   char *fname, *rname;
   #ifndef __APPLE__
   struct spacectl_range sr;
   #endif

   fd = -1;
   #ifdef __APPLE__
   rsize = tsize = sz = 0;
   no_create = do_relative = do_round = do_refer =
   got_size = 0;
   #else
   rsize = tsize = sz = off = 0;
   len = -1;
   do_dealloc = no_create = do_relative = do_round = do_refer =
   got_size = 0;
   #endif
   do_truncate = 1;
   error = r = 0;
   rname = NULL;
   */

  func parseOptions() async throws(CmdErr) -> CommandOptions {
    var opts = CommandOptions()
    //    while ((ch = getopt(argc, argv, "HLPRfhvx")) != -1)
    let go = BSDGetopt("cr:s:")
    while let (k,v) = try go.getopt() {
      switch k {

          //  "cdr:s:o:l:"   // not Apple
        case "c":
          opts.no_create = true


       case "d": // not possible because Apple does not have this option
          opts.do_dealloc = true
          opts.do_truncate = false

        case "r":
          opts.do_refer = true
          opts.rname = v
        case "s":
          if v.hasPrefix("+") || v.hasPrefix("-") {
            opts.do_relative = true
          } else if v.hasPrefix("%") || v.hasPrefix("/") {
            opts.do_round = true
          }
          do {
            let usz = try expand_number(opts.do_relative || opts.do_round ?
                                        String(v.dropFirst()) : v)
            guard let kk = Int(exactly: usz) else { throw SimpleError.message("invalid size argument `\(v)'") }
            let jj = v.hasPrefix("-") || v.hasPrefix("/") ? -kk : kk
            opts.sz = jj
            opts.got_size = true
          } catch {
            errx(Int(EXIT_FAILURE), "invalid size argument `\(v)'")
          }

          /*
           case 'o':
           if (expand_number(optarg, &usz) == -1 ||
           (off_t)usz < 0)
           errx(EXIT_FAILURE,
           "invalid offset argument `%s'", optarg);

           off = usz;
           break;
           case 'l':
           if (expand_number(optarg, &usz) == -1 ||
           (off_t)usz <= 0)
           errx(EXIT_FAILURE,
           "invalid length argument `%s'", optarg);

           len = usz;
           break;
           */
        default:
          throw CmdErr(1)
      }

    }
    opts.args = go.remaining

    /*
     * Exactly one of do_refer, got_size or do_dealloc must be specified.
     * Since do_relative implies got_size, do_relative, do_refer and
     * do_dealloc are also mutually exclusive.  If do_dealloc is specified,
     * the length argument must be set.  See usage() for allowed
     * invocations.
     */
    if opts.args.isEmpty || ((opts.do_refer ? 1 : 0) + (opts.got_size ? 1 : 0) + (opts.do_dealloc ? 1 : 0) ) != 1 {
      /*
       if (argc < 1 || do_refer + got_size + do_dealloc != 1 ||
       (do_dealloc == 1 && len == -1))
       #endif
       */
      throw CmdErr(1)
    }
    return opts
  }



  func runCommand(_ opts : CommandOptions) async throws(CmdErr) {

    var tsize = 0
    if opts.do_refer  {
      var sb : stat = stat()
      if (stat(opts.rname, &sb) == -1) {
        err(Int(EXIT_FAILURE), opts.rname);
      }
      tsize = Int(sb.st_size)
    }
    else if !opts.do_dealloc {
      tsize = opts.sz
    }

    var error = 0
    for fname in opts.args {
      error += once(fname, opts, tsize)
    }
    exit(error > 0 ? EXIT_FAILURE : EXIT_SUCCESS)
  }

  func once(_ fname : String, _ opts : CommandOptions, _ ttsize : Int) -> Int {
    let oflags = opts.no_create ? O_WRONLY : O_WRONLY | O_CREAT
    let omode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH
    var sb : stat = stat()

    var tsize = ttsize

    let fd = Darwin.open(fname, oflags, omode)
    if fd == -1 {
      if (errno != ENOENT) {
        warn(fname)
        return 1
      }
      return 0
    }
    defer { close(fd) }

    if opts.do_relative {
      if (fstat(fd, &sb) == -1) {
        warn(fname)
        return 1
      }
      let oflow = Int(sb.st_size) + opts.sz
      if oflow < Int(sb.st_size) + opts.sz {
        errno = EFBIG;
        warn(fname)
        return 1
      }
      tsize = oflow;
    }
    if opts.do_round {
      if (fstat(fd, &sb) == -1) {
        warn(fname)
        return 1
      }
      var sz = opts.sz
      if (sz < 0) {
        sz = -sz
      }
      if (Int(sb.st_size) % sz) != 0 {
        var round = Int(sb.st_size) / sz
        if (round != sz && opts.sz < 0) {
          round -= 1
        }
        else if (opts.sz > 0) {
          round += 1
        }
        tsize = (round < 0 ? 0 : round) * sz;
      } else {
        tsize = Int(sb.st_size)
      }
    }
    if (tsize < 0) {
      tsize = 0
    }

    /*
     if opts.do_dealloc {
     sr.r_offset = off;
     sr.r_len = len;
     r = fspacectl(fd, SPACECTL_DEALLOC, &sr, 0, &sr);
     }
     */

    var r : Int32 = 0
    if opts.do_truncate {
      r = ftruncate(fd, Int64(tsize))
    }
    if (r == -1) {
      warn(fname)
      return 1
    }
    return 0
  }

  var usage = """
usage: truncate [-c] -s [+|-|%|/]size[K|k|M|m|G|g|T|t] file ...
       truncate [-c] -r rfile file ...
"""
}
